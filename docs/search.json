[{"path":"https://sydneybiox.github.io/ScdneySpatial/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Sean Davis Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Unlocking single cell spatial omics analyses with scdney","text":"Understanding interplay different types cells immediate environment critical understanding mechanisms cells function context human diseases. Recent advances high dimensional situ cytometry technologies fundamentally revolutionized ability observe complex cellular relationships providing unprecedented characterisation cellular heterogeneity tissue environment.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"description","dir":"Articles","previous_headings":"Overview","what":"Description","title":"Unlocking single cell spatial omics analyses with scdney","text":"workshop introduce key analytical concepts needed analyse data high dimensional spatial omics technologies , PhenoCycler, IMC, Xenium MERFISH. show functionality Bioconductor packages simpleSeg, FuseSOM, scClassify, scHot, spicyR, listClust, statial, scFeatures ClassifyR can used address various biological hypotheses. end workshop attendees able implement assess key steps spatial analysis pipeline including cell segmentation, feature normalisation, cell type identification, microenvironment cell-state characterisation, spatial hypothesis testing patient classification. Understanding key steps provide attendees core skills needed interrogate comprehensive spatial information generated exciting new technologies.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"pre-requisites","dir":"Articles","previous_headings":"Overview","what":"Pre-requisites","title":"Unlocking single cell spatial omics analyses with scdney","text":"expected students : basic knowledge R syntax, workshop provide -depth description cell-resolution spatial omics technologies.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"r-bioconductor-packages-used","dir":"Articles","previous_headings":"Overview","what":"R / Bioconductor packages used","title":"Unlocking single cell spatial omics analyses with scdney","text":"Several single cell R packages used scdney package, information visit: https://sydneybiox.github.io/scdney/.","code":""},{"path":[]},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"learning-objectives","dir":"Articles","previous_headings":"Overview","what":"Learning objectives","title":"Unlocking single cell spatial omics analyses with scdney","text":"Understand visualise spatial omics datasets. Identify key biological questions can addressed technologies spatial analysis. Understand key analytical steps involved spatial omics analysis, perform steps using R. Evaluate performance data normalisation cell segmentation. Understand generate individual feature representations spatial omics data. Develop appreciation assess performance classification models. Perform disease outcome prediction using feature representation robust classification framework.","code":""},{"path":[]},{"path":[]},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"installation","dir":"Articles","previous_headings":"Setup","what":"Installation","title":"Unlocking single cell spatial omics analyses with scdney","text":"","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE)) {     install.packages(\"BiocManager\") }  BiocManager::install(c( \"simpleSeg\", \"cytomapper\", \"scClassify\", \"scHOT\", \"FuseSOM\",\"glmnet\", \"spicyR\", \"lisaClust\",\"Statial\", \"scFeatures\", \"ClassifyR\", \"tidyverse\", \"scater\", \"SingleCellExperiment\", \"STexampleData\", \"SpatialDatasets\", \"tidySingleCellExperiment\", \"scuttle\", \"batchelor\"))"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"download-datasets","dir":"Articles","previous_headings":"Setup","what":"Download datasets","title":"Unlocking single cell spatial omics analyses with scdney","text":"Please download datasets start workshop","code":"#Download data now spe <- STexampleData::seqFISH_mouseEmbryo() kerenSPE = SpatialDatasets::spe_Keren_2018()"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"load-packages","dir":"Articles","previous_headings":"Setup","what":"Load packages","title":"Unlocking single cell spatial omics analyses with scdney","text":"","code":"# packages from scdney library(ClassifyR) library(FuseSOM) library(lisaClust) library(scClassify) library(scFeatures)  library(scHOT) library(simpleSeg) library(SpatialDatasets) library(spicyR) library(Statial)  # Other required packages library(BumpyMatrix) library(cytomapper) library(batchelor) library(ggplot2) library(ggsurvfit) library(glmnet) library(plotly) library(reshape) library(scater) library(scuttle) library(SingleCellExperiment) library(STexampleData) library(tidySingleCellExperiment) library(tidyverse)  theme_set(theme_classic())  nCores <- 8  # Feel free to parallelise things if you have the cores to spare. BPPARAM <- simpleSeg:::generateBPParam(nCores) source(system.file(\"extdata\", \"celltype_colours.R\", package = \"ScdneySpatial\")) options(\"restore_SingleCellExperiment_show\" = TRUE)"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"module-1-data-exploration","dir":"Articles","previous_headings":"","what":"Module 1: Data exploration","title":"Unlocking single cell spatial omics analyses with scdney","text":"workshop, working two datasets explore biological phenotypes, cellular interactions, patterns gene expression correlated disease. datasets used different contexts, hopefully contexts representative scenarios encounter datasets. use two motivating datasets: Keren et al, 2018: multiplexed ion beam imaging time--flight (MIBI-TOF) dataset profilining tissue triple-negative breast cancer patients. primary question address dataset can predict risk cancer recurrence overall survival time based imaging data? Lohoff et al, 2022: seqFISH study early mouse organogenesis. use subset data made available STExampleData package. primary question address dataset can identify key transcriptomic drivers developing brain? purpose section primarily introduce SpatialExperiment class used store information imaging experiments R. goal get comfortable enough manipulating exploring objects can progress remainder workshop comfortably. download dataset stored STexampleData R package, examine structure, visualise data perform exploratory analyses. Spatial transcriptomics - SeqFISH mouse embryo Spatial proteomics - MIBI-TOF breast cancer download seqFISH mouse embryo data. comes format SpatialExperiment object, summarized information imaging dataset can compiled accessed relative ease. can use functions designed SingleCellExperiment objects scater package plotting via reducedDim slot. multiply spatial coordinates matrix flip y-axis ensure fix aspect ratio.  Questions many cells data? many genes? Plot gene expression mapping point size cell area. can perform typical gene-expression based analysis data. Later part two perform specific analytical techniques, now let’s explore dataset use methods designed single cell data. Typically single-cell data analysis, perform dimension reduction project high dimensional cell x gene matrix 2D space. allows us visualise various things interest, distribution cell types disease outcomes. , see cells segregated expression Sox2.    Advanced/Extension Question considerations need made batch correction spatial data? assumptions made /broken? check ? Check ggiraph package extending g_all object interactive plot tooltip links spatial UMAP coordinate systems. (Hint: may involve generating new ggplot object outside plotReducedDim function.) part scdney package infrastructure, provide several pre-processed datasets can loaded SpatialDatasets package. , ’ve loaded MIBI-TOF triple negative breast cancer data Keren et al. SpatialExperiment object. start analysis, often good explore data get sense complexity. can exploring distribution outcomes variables patients’ meta-data. Try starting exploration answering questions. Questions many cells data? many markers? many images? , can perform dimension reduction visualize dataset 2D plane. Questions Visualise UMAP using plotReducedDim function colour UMAP cellType. UMAP tell us? observations make coloured imageID?","code":"#spe <- STexampleData::seqFISH_mouseEmbryo() spe #> class: SpatialExperiment  #> dim: 351 11026  #> metadata(0): #> assays(2): counts molecules #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(1): gene_name #> colnames(11026): embryo1_Pos0_cell10_z2 embryo1_Pos0_cell100_z2 ... #>   embryo1_Pos28_cell97_z2 embryo1_Pos28_cell98_z2 #> colData names(14): cell_id embryo ... segmentation_vertices sample_id #> spatialCoords names(2) : x y #> imgData names(0): spe <- logNormCounts(spe) coord_transform <- matrix(c(1,0,0,-1), 2, 2, byrow = TRUE) reducedDim(spe, \"spatialCoords\") <- spatialCoords(spe) %*% coord_transform plotReducedDim(spe, \"spatialCoords\", colour_by = c(\"Sox2\"), point_size = 1) +   coord_fixed() # try to answer the above question using the spe object.  # you may want to check the SingleCellExperiment vignette. # https://bioconductor.org/packages/3.17/bioc/vignettes/SingleCellExperiment/inst/doc/intro.html spe <- runPCA(spe)  b.out <- batchelor::batchCorrect(spe, batch = spe$pos, assay.type = \"logcounts\", PARAM=FastMnnParam(d=20)) reducedDim(spe, \"FastMnn\") <- reducedDim(b.out, \"corrected\") spe <- runUMAP(spe, dimred = \"FastMnn\") spe #> class: SpatialExperiment  #> dim: 351 11026  #> metadata(0): #> assays(3): counts molecules logcounts #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(1): gene_name #> colnames(11026): embryo1_Pos0_cell10_z2 embryo1_Pos0_cell100_z2 ... #>   embryo1_Pos28_cell97_z2 embryo1_Pos28_cell98_z2 #> colData names(15): cell_id embryo ... sample_id sizeFactor #> spatialCoords names(2) : x y #> imgData names(1): sample_id g_celltype_umap <- plotReducedDim(spe, \"UMAP\", colour_by = \"celltype_mapped_refined\") +    scale_colour_manual(values = celltype_colours) g_celltype_umap plotReducedDim(spe, \"UMAP\", colour_by = \"Sox2\") g_celltype_spatial <- plotReducedDim(spe, \"spatialCoords\", colour_by = \"celltype_mapped_refined\") +    scale_colour_manual(values = celltype_colours) +    coord_fixed()  g_all <- g_celltype_spatial + theme(legend.position = \"none\") + g_celltype_umap g_all # try to examine answer the above questions using the spe object.  # you may want to set up some small simulation.. # Load in Keren et al. data. #kerenSPE = SpatialDatasets::spe_Keren_2018()   # Remove cold tumour types and patients with missing survival data. kerenSPE = kerenSPE |>    filter(tumour_type != \"cold\",          !is.na(`Survival_days_capped.`)) |>    mutate(event = 1 - Censored)  colData(kerenSPE)$x <- spatialCoords(kerenSPE)[,1] colData(kerenSPE)$y <- spatialCoords(kerenSPE)[,2]  reducedDim(kerenSPE, \"spatialCoords\") <- spatialCoords(kerenSPE)  kerenSPE #> class: SpatialExperiment  #> dim: 48 170171  #> metadata(0): #> assays(1): intensities #> rownames(48): Na Si ... Ta Au #> rowData names(0): #> colnames(170171): 1 2 ... 197677 197678 #> colData names(43): CellID imageID ... x y #> spatialCoords names(2) : x y #> imgData names(1): sample_id # try to answer the above question using the imc object.  # you may want to check the SpatialExperiment vignette. # https://www.bioconductor.org/packages/release/bioc/vignettes/SpatialExperiment/inst/doc/SpatialExperiment.html set.seed(51773) kerenSPE <- scater::runUMAP(kerenSPE, exprs_values = \"intensities\", name = \"UMAP\")   # try to answer the question here!"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"module-2-cell-segmentation","dir":"Articles","previous_headings":"","what":"Module 2: Cell segmentation","title":"Unlocking single cell spatial omics analyses with scdney","text":"load images R? visualise images? Can identify cells image? Can one step? segmentation appropriate? Im happy segmentation, create SPE object? load images use loadImages function cytomapper, use patient 5 image Keren et al. example. Questions class image5? Hint: class() many images markers image5? Challenge: dimension image5 image? can visualise image see read . Lets highlight 4 markers.  can manipulate brightness, contrast gamma levels follows. See can better job.  EBImage package Bioconductor provides lot useful functions manipulating imaging data R. includes functionality finding cells, process called cell segmentation. Lets work example vignette. use functionality complements ’ve already learnt. start loading images nuclei cell bodies. visualize cells overlay images green blue channel false-color image. Notice, display can zoom!  next segment nuclei. nuc channel contains fluorescent intensities protein expressed nuclei cells. First create nuclei mask threshold channel separate signal noise clean morphological operations. identify single nuclei using bwlabel.  Questions understand nmask ? seeing table(nmask) happens using colorLabels() display? Next, use segmented nuclei seeds perform Voronoi segmentation cytoplasm.  can visualise segmentations paintObjects.  Images stored list CytoImageList can segmented using simpleSeg. simpleSeg identify nuclei image using dsDNA, H3K27me3 H3K9ac channel. estimate cell body cells simply dilate nuclei 3 pixels. also specified channels sqrt transformed, 99th quantile values removed ensure segmentation affected outliers. can visualise segmentations using display colorLabels functions EBImage. One way assess segmentation appropriate look. now know two ways .  plotPixels function cytomapper makes easy overlay masks top intensities markers image. can s  Using table function R can measure pixel area cell plot histogram. dataset 1 µm equivalent \\(2.56\\) pixels, can transform pixel area cell physical area dividing pixel area \\(2.56^2\\). can see majority cells just \\(100µm^2\\), decide whether appropriate size based knowledge cell types imaged.  Questions segmentations look better parameters used? Hint: use help function see parameters available simpleSeg. one image , check quality 100 images? segmentation masks can convert image SpatialExperiment object using measureObjects function cytomapper. measureObjects find center cell represent cell x y coordinate. addition average marker expression within cell summarised stored assays object SpatialExperiment. NOTE: using segmentation tools softwares, can import masks tiffs R use measureObjects create SpatialExperiment.","code":"imageLocation <- system.file(\"extdata\", \"kerenPatient5.tiff\", package = \"ScdneySpatial\") image5 = cytomapper::loadImages(   x = imageLocation,   as.is = TRUE #Needed as 8-bit image )  mcols(image5) = data.frame(list(\"imageID\" = \"kerenPatient5\"))  # Setting the channel names according to orginal paper.  channelNames(image5) = c(\"Au\", \"Background\", \"Beta catenin\", \"Ca\", \"CD11b\", \"CD11c\", \"CD138\", \"CD16\", \"CD20\", \"CD209\", \"CD3\", \"CD31\", \"CD4\", \"CD45\", \"CD45RO\", \"CD56\", \"CD63\", \"CD68\", \"CD8\", \"dsDNA\", \"EGFR\", \"Fe\", \"FoxP3\", \"H3K27me3\", \"H3K9ac\", \"HLA_Class_1\", \"HLA_DR\", \"IDO\", \"Keratin17\", \"Keratin6\", \"Ki67\", \"Lag3\", \"MPO\", \"Na\", \"P\", \"p53\", \"Pan-Keratin\", \"PD-L1\", \"PD1\", \"phospho-S6\", \"Si\", \"SMA\", \"Ta\", \"Vimentin\") # Answer questions here # Visualise segmentation performance another way. cytomapper::plotPixels(   image = image5[1],   colour_by = c(\"CD45\", \"Pan-Keratin\", \"SMA\", \"dsDNA\"),   colour = list(     CD45 = c(\"black\", \"blue\"),     `Pan-Keratin` = c(\"black\", \"yellow\"),     SMA = c(\"black\", \"green\"),     dsDNA = c(\"black\", \"red\")   ) ) # Visualise segmentation performance another way. cytomapper::plotPixels(   image = image5[1],   colour_by = c(\"CD45\", \"Pan-Keratin\", \"SMA\", \"dsDNA\"),   display = \"single\",   colour = list(     CD45 = c(\"black\", \"red\"),     `Pan-Keratin` = c(\"black\", \"yellow\"),     SMA = c(\"black\", \"green\"),     dsDNA = c(\"black\", \"blue\")   )   ,   # Adjust the brightness, contrast and gamma of each channel.   bcg = list(     CD45 = c(0, 4, 1),     `Pan-Keratin` = c(0, 3, 1),     SMA = c(0, 2, 1),     dsDNA = c(0, 2, 1)   ),   legend = NULL ) nuc = readImage(system.file('images', 'nuclei.tif', package='EBImage'))  cel = readImage(system.file('images', 'cells.tif', package='EBImage'))   cells = rgbImage(green=1.5*cel, blue=nuc)  display(cells, all = TRUE) nmask = thresh(nuc, w=10, h=10, offset=0.05) nmask = opening(nmask, makeBrush(5, shape='disc')) nmask = fillHull(nmask) nmask = bwlabel(nmask)  display(nmask, all=TRUE) ctmask = opening(cel>0.1, makeBrush(5, shape='disc')) cmask = propagate(cel, seeds=nmask, mask=ctmask)  display(ctmask, all=TRUE) segmented = paintObjects(cmask, cells, col='#ff00ff') segmented = paintObjects(nmask, segmented, col='#ffff00')  display(segmented, all=TRUE) # Generate segmentation masks masks <- simpleSeg(   image5,   nucleus = c(\"dsDNA\", \"H3K27me3\", \"H3K9ac\"),   cellBody = \"dilate\",    transform = c(\"sqrt\", \"norm99\"),   sizeSelection = 40,   smooth = 3,   discSize = 3,   cores = nCores ) # Visualise segmentation performance one way. masks[[1]] |>    EBImage::colorLabels() |>    EBImage::display() # Visualise segmentation performance another way. cytomapper::plotPixels(   image = image5[1],   mask = masks[1],   img_id = \"imageID\",   colour_by = c(\"CD45\", \"Pan-Keratin\", \"SMA\", \"dsDNA\"),   display = \"single\",   colour = list(     CD45 = c(\"black\", \"red\"),     `Pan-Keratin` = c(\"black\", \"yellow\"),     SMA = c(\"black\", \"green\"),     dsDNA = c(\"black\", \"blue\")   ),   # Adjust the brightness, contrast and gamma of each channel.   bcg = list(     CD45 = c(0, 4, 1),     `Pan-Keratin` = c(0, 3, 1),     SMA = c(0, 2, 1),     dsDNA = c(0, 4, 1)   ),   legend = NULL ) # Get area of every cell cellSize = table(masks[[1]])/(2.56^2)  # Filter out first index, which represents background cellSize[2:length(cellSize)] |>    hist(breaks = 30,        xlab = \"Pixel area of cell (µm^2)\",        main = NULL) # Summarise the expression of each marker in each cell cells <- cytomapper::measureObjects(   mask = masks,   image = image5,   feature_types = c(\"basic\", \"moment\"),   basic_feature = \"mean\",   moment_feature = c(\"cx\", \"cy\"),   img_id = \"imageID\",   BPPARAM = BPPARAM )   cells #> class: SingleCellExperiment  #> dim: 44 3739  #> metadata(0): #> assays(1): counts #> rownames(44): Au Background ... Ta Vimentin #> rowData names(0): #> colnames: NULL #> colData names(5): imageID object_id m.cx m.cy objectNum"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"module-3-feature-normalisation","dir":"Articles","previous_headings":"","what":"Module 3: Feature normalisation","title":"Unlocking single cell spatial omics analyses with scdney","text":"intensities markers consistent across images? can transform normalise data? moving onto annotating cell types, check marker intensities cell require transformation normalisation. examine distribution CD45 cell across images, general marker immune cells. can see intensity CD45 looks skewed.  can transform normalise data using normalizeCells function simpleSeg. taken intensities intensities assay, performed asinh transform, image trimmed 99 quantile min-max scaled 0-1. addition performed principle component analysis, regressed first PC. modified data stored normIntensities assay. can see distribution CD45 looks much less skewed .  Questions CD3 marker characterises T cells, plot distribution CD3. look like? tell us T cells dataset. set cellType == \"CD4_T_cell\" concordant conclusion made question 1.","code":"# Joining the marker information with the cell information proteinIntensities = kerenSPE |>    join_features(features = rownames(kerenSPE), shape = \"wide\", assay = \"intensities\")  # View the density of CD45 across all images. ggplot(proteinIntensities, aes(x = CD45, colour = imageID)) +   geom_density() +   theme(legend.position = \"none\") kerenSPE <- normalizeCells(   cells = kerenSPE,   transformation = \"asinh\",   method = c(\"trim99\", \"minMax\", \"PC1\"),   assayIn = \"intensities\",   assayOut = \"normIntensities\",   cores = nCores )   normProteinIntensities = kerenSPE |>    join_features(features = rownames(kerenSPE), shape = \"wide\", assay = \"normIntensities\")  ggplot(normProteinIntensities, aes(x = CD3, colour = imageID)) +   geom_density() +   theme(legend.position = \"none\") # Answer question here"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"module-4-cell-type-annotation","dir":"Articles","previous_headings":"","what":"Module 4: Cell type annotation","title":"Unlocking single cell spatial omics analyses with scdney","text":"Can use clustering approach identify cell types? interpret clusters? appropriate number clusters? don’t expert annotate cell types? Viewing images cluster using runFuseSOM function FuseSOM. chosen specify subset markers used original manuscript gating cell types. also specified number clusters identify numClusters = 17. can begin process understanding cell clusters using plotGroupedHeatmap function scater.  Questions captured distinct cell populations? Can identify clusters? Run code compare cell types dataset clusters identified. clusters compare? clusters combined?  Great question! right answer , however several statistics can used estimate “true” number clusters. can use estimateNumCluster optiPlot functions FuseSOM examine choice 17 clusters reasonable. use gap statistic, methods jump, slope, silhouette within cluster distance (wcd) also available.  Finally can run UMAP examine distinct clusters one another.  Questions UMAP compare original UMAP? Cell type clustering may difficult without aid domain experts know many cell types expect able annotate clusters. Cell type classification alternative approach clustering annotates cell types based expert labeled reference dataset. use scClassify. use intensities cell type annotations kerenSPE dataset predict cell types image 5. scClassify first constructs cell type tree training dataset, cells organised hierarchy increasingly fined tuned annotations, use HOPACH method construct tree. tree constructed using proteins differentially expressed one cell type cells, identified using limma. annotate cells unlabeled dataset, unlabeled cells projected lower dimensional space weighted KNN (WKNN) used classify unlabeled cells closest neighbours using pearson correlation distance metric. save time preloaded scClassify results, can view hierarchical tree constructed scClassify.  look predictions, can observe cells belonging multiple cell types. represent cells classified parent populations hierarchical tree. clean names make plotting easier. can compare original labels classified labels get sense concordant predictions . can see, around 68% cell types identical labels original classified cell types. can look distribution cells image. compare clusters classified cell types cell types dataset.      Questions Discuss amongst peers, might differences clusters, classified cell types original cell type labels dataset?","code":"useMarkers = c(\"CD45\", \"FoxP3\", \"CD4\", \"CD8\", \"CD3\", \"CD20\", \"CD16\", \"CD68\", \"MPO\", \"HLA.DR\", \"Pan.Keratin\", \"Keratin17\", \"Keratin6\", \"p53\", \"Beta.catenin\", \"EGFR\")  set.seed(51773)  kerenSPE <- runFuseSOM(   kerenSPE,   markers = useMarkers,   assay = \"normIntensities\",   numClusters = 17 ) scater::plotGroupedHeatmap(   kerenSPE,   features = useMarkers,   group = \"clusters\",   exprs_values = \"normIntensities\",   center = TRUE,   scale = TRUE,   zlim = c(-3, 3),   cluster_rows = FALSE ) # Type your answer here   # Question 2 code regionMap(kerenSPE, cellType = \"clusters\", region = \"cellType\") +   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +   labs(x = \"Cell types in data\", y = \"Our clusters\") kerenSPE <- estimateNumCluster(kerenSPE, kSeq = 2:30) optiPlot(kerenSPE, method = \"gap\") kerenSPE@metadata$clusterEstimation$Discriminant #> [1] 10 set.seed(51773) # Perform dimension reduction using UMP. kerenSPE <- scater::runUMAP(   kerenSPE,   subset_row = useMarkers,   exprs_values = \"normIntensities\",   name = \"normUMAP\" )    # UMAP by cell type cluster. scater::plotReducedDim(   kerenSPE,   dimred = \"normUMAP\",   colour_by = \"clusters\" ) # Answer question here. # Splitting data to train and test sets kerenSPE_train = kerenSPE |>    filter(imageID != 5)  kerenSPE_test = kerenSPE |>    filter(imageID == 5 )   # Converting intensities to dgCMatrix train_intensities = assay(kerenSPE_train, \"intensities\") |>     as.matrix() |>    as( \"dgCMatrix\")   test_intensities = assay(kerenSPE_test, \"intensities\") |>     as.matrix() |>    as( \"dgCMatrix\") scClassifyResults = scClassify(exprsMat_train = train_intensities,                              cellTypes_train = kerenSPE_train$cellType,                             exprsMat_test = list(keren5 = test_intensities),                             tree = \"HOPACH\",                             algorithm = \"WKNN\",                             selectFeatures = c(\"limma\"),                             similarity = c(\"pearson\"),                             returnList = FALSE,                             verbose = FALSE,                             BPPARAM = BPPARAM) load(file = system.file(\"extdata\", \"scClassifyResults.rda\", package = \"ScdneySpatial\"))  plotCellTypeTree(cellTypeTree(scClassifyResults$trainRes)) classifiedCellTypes = scClassifyResults$testRes$keren5$pearson_WKNN_limma$predRes  table(classifiedCellTypes) #> classifiedCellTypes #>                                                                                           B_cell  #>                                                                                                2  #>                                                                                       CD4_T_cell  #>                                                                                              209  #>                                                                                       CD8_T_cell  #>                                                                                              440  #>                                                                                               DC  #>                                                                                                1  #>                                                                                       DC_or_Mono  #>                                                                                              217  #>                                                               DC_or_Mono_Macrophages_Mono_or_Neu  #>                                                                                              122  #>                                                                                         dn_T_CD3  #>                                                                                               36  #>                                                            dn_T_CD3_B_cell_CD4_T_cell_CD8_T_cell  #>                                                                                                1  #> dn_T_CD3_B_cell_CD4_T_cell_DC_or_Mono_Macrophages_CD8_T_cell_Mono_or_Neu_Neutrophils_NK_DC_Tregs  #>                                                                                              194  #>                                                                   dn_T_CD3_CD4_T_cell_CD8_T_cell  #>                                                                                               70  #>                                                                                      Endothelial  #>                                                                                              102  #>                                                                          Endothelial_Mesenchymal  #>                                                                                               11  #>                                                                                   Keratin_Tumour  #>                                                                                             1901  #>                          Keratin_Tumour_Unidentified_Other_Immune_Endothelial_Mesenchymal_Tumour  #>                                                                                              417  #>                                                                                      Macrophages  #>                                                                                              857  #>                                                                          Macrophages_Mono_or_Neu  #>                                                                                              130  #>                                                                                      Mesenchymal  #>                                                                                               76  #>                                                                                      Mono_or_Neu  #>                                                                                               35  #>                                                                                      Neutrophils  #>                                                                                               65  #>                                                                                     Other_Immune  #>                                                                                               75  #>                                                             Other_Immune_Endothelial_Mesenchymal  #>                                                                                               55  #>                                                                                            Tregs  #>                                                                                               31  #>                                                                                           Tumour  #>                                                                                               16  #>                                                                                       unassigned  #>                                                                                              335  #>                                                                                     Unidentified  #>                                                                                                4  #>                                                                              Unidentified_Tumour  #>                                                                                                4 newCellTypes = case_when(   classifiedCellTypes == \"Keratin_Tumour_Unidentified_Other_Immune_Endothelial_Mesenchymal_Tumour\" ~ \"Tumour_parent\",   classifiedCellTypes == \"Other_Immune_Endothelial_Mesenchymal\" ~ \"Structural_parent\",   classifiedCellTypes == \"Macrophages_Mono_or_Neu\" ~ \"Monocyte_subparent\",   classifiedCellTypes == \"DC_or_Mono_Macrophages_Mono_or_Neu\" ~ \"Monocyte_parent\",   classifiedCellTypes == \"dn_T_CD3_B_cell_CD4_T_cell_DC_or_Mono_Macrophages_CD8_T_cell_Mono_or_Neu_Neutrophils_NK_DC_Tregs\" ~ \"Immune_parent\",   classifiedCellTypes == \"dn_T_CD3_CD4_T_cell_CD8_T_cell\" ~ \"Tcell_parent\",   classifiedCellTypes == \"Endothelial_Mesenchymal\" ~ \"Structural_parent\",   classifiedCellTypes == \"dn_T_CD3_B_cell_CD4_T_cell_CD8_T_cell\" ~ \"Lymphocytes_parent\",   TRUE ~ classifiedCellTypes )  kerenSPE_test$classifiedCellTypes = newCellTypes   (kerenSPE_test$cellType == kerenSPE_test$classifiedCellTypes) |>    mean() #> [1] 0.6877543 reducedDim(kerenSPE, \"spatialCoords\") <- spatialCoords(kerenSPE)  kerenSPE |>    filter(imageID == \"5\") |>    plotReducedDim(\"spatialCoords\", colour_by = \"clusters\") +   ggtitle(\"Our clusters\") reducedDim(kerenSPE_test, \"spatialCoords\") = spatialCoords(kerenSPE_test)  # Filter out the \"parent\" classified cells kerenSPE_test |>    filter(classifiedCellTypes %in% unique(kerenSPE$cellType)) |>    plotReducedDim(\"spatialCoords\", colour_by = \"classifiedCellTypes\") +   ggtitle(\"Classified cell types\") kerenSPE |>    filter(imageID == \"5\") |>    plotReducedDim(\"spatialCoords\", colour_by = \"cellType\") +   ggtitle(\"Original cell types\") # Comparing orignal cell types to clustering and classification cell types.  regionMap(kerenSPE, cellType = \"clusters\", region = \"cellType\") +   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +   ggtitle(\"Original vs Clustered\") +   labs(x = \"Original cell labels\", y = \"Clustering cell labels\") regionMap(kerenSPE_test, cellType = \"classifiedCellTypes\", region = \"cellType\") +   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +   ggtitle(\"Original vs Classified\") +   labs(x = \"Original cell labels\", y = \"Classified cell labels\")"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"module-5-single-sample-analysis","dir":"Articles","previous_headings":"","what":"Module 5: Single sample analysis","title":"Unlocking single cell spatial omics analyses with scdney","text":"module focus examining gene expression patterns single image, SeqFISH mouse embryo dataset. genes change expression across space? ask gene patterns observe changing across spe$gutRegion cell type space. Note want assess anatomical region corresponding anterior end developing gut developing brain first subset cells using spatial coordinates. can check selected plotting.  Let’s subset data cells continue scHOT analysis. select genes least proportion expressed cells testing, create scHOT object.  now add testing scaffold scHOT object, set local weight matrix testing, choice span 0.1 (proportion cells weight around cell). can speed computation requiring weight matrix correspond every individual cell, instead random selection among cells using thin function. given cell can visually examine local weight given span parameter.  Question results change span increased/decreased? set higher order function weighted mean function, calculate observed higher order test statistics. may take around 10 seconds. Now can plot overall mean versus scHOT statistic observe relationship. Labels can interactively visualised using ggplotly. genes may different distributions turn permutation testing assess statistical significance.  Set permutation testing schema. purposes workshop set low number permutations low number genes testing scaffold, may want change work workshop . testing take minutes run, parallel parameters set beginning document. permutation test can estimate P-values across genes.  can now examine spatial expression 5 significant genes, scHOT object original spe object.  noting genes found statistically significant spatial variation local mean expression. genes point specific patterns govern development individual parts gut tube. Advanced/Extended Questions perform testing multiple distinct samples? scHOT developed higher order testing mind, use associated vignette get towards assessing changes variation correlation structure space.","code":"# Filter cells which are labeled gut tub, and in the anterior section. spe$gutRegion <- spe$celltype_mapped_refined == \"Gut tube\" &   reducedDim(spe, \"spatialCoords\")[,1] < -0.5  plotReducedDim(spe, \"spatialCoords\", colour_by = \"gutRegion\") +    coord_fixed() +    scale_colour_manual(values = c(\"TRUE\" = \"red\", \"FALSE\" = \"grey\")) spe_gut <- spe[,spe$gutRegion] spe_gut #> class: SpatialExperiment  #> dim: 351 472  #> metadata(0): #> assays(3): counts molecules logcounts #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(1): gene_name #> colnames(472): embryo1_Pos3_cell377_z2 embryo1_Pos3_cell388_z2 ... #>   embryo1_Pos27_cell74_z2 embryo1_Pos28_cell373_z2 #> colData names(16): cell_id embryo ... sizeFactor gutRegion #> spatialCoords names(2) : x y #> imgData names(1): sample_id hist(rowMeans(counts(spe_gut)>0), 40) gene_to_test <- as.matrix(c(rownames(spe_gut[rowMeans(counts(spe_gut)>0) > 0.2,]))) length(gene_to_test) #> [1] 165 rownames(gene_to_test) <- apply(gene_to_test, 1, paste0, collapse = \"_\") head(gene_to_test) #>         [,1]      #> Acvr1   \"Acvr1\"   #> Acvr2a  \"Acvr2a\"  #> Ahnak   \"Ahnak\"   #> Akr1c19 \"Akr1c19\" #> Aldh1a2 \"Aldh1a2\" #> Aldh2   \"Aldh2\" scHOT_spatial <- scHOT_buildFromSCE(spe_gut,                                     assayName = \"logcounts\",                                     positionType = \"spatial\",                                     positionColData = c(\"x_global_affine\", \"y_global_affine\"))  scHOT_spatial #> class: scHOT  #> dim: 351 472  #> metadata(0): #> assays(1): expression #> rownames(351): Abcc4 Acp5 ... Zfp57 Zic3 #> rowData names(0): #> colnames(472): embryo1_Pos3_cell377_z2 embryo1_Pos3_cell388_z2 ... #>   embryo1_Pos27_cell74_z2 embryo1_Pos28_cell373_z2 #> colData names(16): cell_id embryo ... sizeFactor gutRegion #> testingScaffold dim: 0 0  #> weightMatrix dim: 0 0  #> scHOT_output colnames (0): #> param names (0): #> position type: spatial scHOT_spatial <- scHOT_addTestingScaffold(scHOT_spatial, gene_to_test) head(scHOT_spatial@testingScaffold) #>         gene_1    #> Acvr1   \"Acvr1\"   #> Acvr2a  \"Acvr2a\"  #> Ahnak   \"Ahnak\"   #> Akr1c19 \"Akr1c19\" #> Aldh1a2 \"Aldh1a2\" #> Aldh2   \"Aldh2\" scHOT_spatial <- scHOT_setWeightMatrix(scHOT_spatial, span = 0.2) scHOT_spatial@weightMatrix <- thin(scHOT_spatial@weightMatrix, n = 50)  dim(slot(scHOT_spatial, \"weightMatrix\")) #> [1]  53 472 cellID = 10  df <- cbind(as.data.frame(colData(scHOT_spatial)),       W = slot(scHOT_spatial, \"weightMatrix\")[cellID,])  ggplot(df,        aes(x = x_global_affine, y = -y_global_affine)) +   geom_point(aes(colour = W, size = W)) +   scale_colour_gradient(low = \"black\", high = \"purple\") +   scale_size_continuous(range = c(0.5,2.5)) +   theme_classic() +   guides(colour = guide_legend(title = \"Spatial Weight\"),          size = guide_legend(title = \"Spatial Weight\")) +   ggtitle(paste0(\"Central cell: \", cellID)) +    coord_fixed() +   NULL ## Make associated changes to the code to test out the question above. scHOT_spatial <- scHOT_calculateGlobalHigherOrderFunction(     scHOT_spatial,     higherOrderFunction = weightedMean,     higherOrderFunctionType = \"weighted\")  slot(scHOT_spatial, \"scHOT_output\") #> DataFrame with 165 rows and 2 columns #>              gene_1 globalHigherOrderFunction #>         <character>                  <matrix> #> Acvr1         Acvr1                  0.216666 #> Acvr2a       Acvr2a                  0.375776 #> Ahnak         Ahnak                  0.976418 #> Akr1c19     Akr1c19                  0.744070 #> Aldh1a2     Aldh1a2                  0.245981 #> ...             ...                       ... #> Wnt5a         Wnt5a                  0.335820 #> Wnt5b         Wnt5b                  0.220300 #> Xist           Xist                  1.162241 #> Zfp444       Zfp444                  0.744082 #> Zfp57         Zfp57                  0.595519 scHOT_spatial <- scHOT_calculateHigherOrderTestStatistics(     scHOT_spatial, na.rm = TRUE) g <- ggplot(as.data.frame(scHOT_spatial@scHOT_output),             aes(x = globalHigherOrderFunction, y = higherOrderStatistic, label = gene_1)) +    xlab(\"Mean across all cells\") +   ylab(\"scHOT statistic for local weightedMean\") +   geom_point() g ggplotly(g) scHOT_spatial <- scHOT_setPermutationScaffold(scHOT_spatial,                                               numberPermutations = 50,                                               numberScaffold = 30)  scHOT_spatial <- scHOT_performPermutationTest(     scHOT_spatial,     verbose = TRUE,     parallel = FALSE) #> Permutation testing combination 80 of 165... slot(scHOT_spatial, \"scHOT_output\") #> DataFrame with 165 rows and 9 columns #>              gene_1 globalHigherOrderFunction            higherOrderSequence #>         <character>                  <matrix>                  <NumericList> #> Acvr1         Acvr1                  0.216666 0.251205,0.275076,0.286668,... #> Acvr2a       Acvr2a                  0.375776 0.398236,0.376223,0.361763,... #> Ahnak         Ahnak                  0.976418    1.23931,1.22101,1.19278,... #> Akr1c19     Akr1c19                  0.744070 0.681732,0.622183,0.625407,... #> Aldh1a2     Aldh1a2                  0.245981 0.117491,0.118105,0.121221,... #> ...             ...                       ...                            ... #> Wnt5a         Wnt5a                  0.335820 0.282418,0.280240,0.268180,... #> Wnt5b         Wnt5b                  0.220300 0.262440,0.321449,0.368172,... #> Xist           Xist                  1.162241    1.18893,1.17123,1.18238,... #> Zfp444       Zfp444                  0.744082 0.529888,0.531771,0.538540,... #> Zfp57         Zfp57                  0.595519 0.853046,0.844188,0.838651,... #>         higherOrderStatistic numberPermutations storePermutations #>                    <numeric>          <numeric>         <logical> #> Acvr1              0.0750954                  0              TRUE #> Acvr2a             0.0665143                  0              TRUE #> Ahnak              0.3319897                  0              TRUE #> Akr1c19            0.1673342                  0              TRUE #> Aldh1a2            0.1827836                 50              TRUE #> ...                      ...                ...               ... #> Wnt5a               0.172300                  0              TRUE #> Wnt5b               0.104924                  0              TRUE #> Xist                0.120828                 50              TRUE #> Zfp444              0.118930                  0              TRUE #> Zfp57               0.130128                  0              TRUE #>                              permutations pvalPermutations FDRPermutations #>                             <NumericList>        <numeric>       <numeric> #> Acvr1                                  NA               NA              NA #> Acvr2a                                 NA               NA              NA #> Ahnak                                  NA               NA              NA #> Akr1c19                                NA               NA              NA #> Aldh1a2 0.0482154,0.0593701,0.0513777,...        0.0196078       0.0231579 #> ...                                   ...              ...             ... #> Wnt5a                                  NA               NA              NA #> Wnt5b                                  NA               NA              NA #> Xist       0.147309,0.134604,0.226559,...             0.46            0.46 #> Zfp444                                 NA               NA              NA #> Zfp57                                  NA               NA              NA scHOT_plotPermutationDistributions(scHOT_spatial) scHOT_spatial <- scHOT_estimatePvalues(scHOT_spatial,                                        nperm_estimate = 100,                                        maxDist = 0.1) slot(scHOT_spatial, \"scHOT_output\") #> DataFrame with 165 rows and 14 columns #>              gene_1 globalHigherOrderFunction            higherOrderSequence #>         <character>                  <matrix>                  <NumericList> #> Acvr1         Acvr1                  0.216666 0.251205,0.275076,0.286668,... #> Acvr2a       Acvr2a                  0.375776 0.398236,0.376223,0.361763,... #> Ahnak         Ahnak                  0.976418    1.23931,1.22101,1.19278,... #> Akr1c19     Akr1c19                  0.744070 0.681732,0.622183,0.625407,... #> Aldh1a2     Aldh1a2                  0.245981 0.117491,0.118105,0.121221,... #> ...             ...                       ...                            ... #> Wnt5a         Wnt5a                  0.335820 0.282418,0.280240,0.268180,... #> Wnt5b         Wnt5b                  0.220300 0.262440,0.321449,0.368172,... #> Xist           Xist                  1.162241    1.18893,1.17123,1.18238,... #> Zfp444       Zfp444                  0.744082 0.529888,0.531771,0.538540,... #> Zfp57         Zfp57                  0.595519 0.853046,0.844188,0.838651,... #>         higherOrderStatistic numberPermutations storePermutations #>                    <numeric>          <numeric>         <logical> #> Acvr1              0.0750954                  0              TRUE #> Acvr2a             0.0665143                  0              TRUE #> Ahnak              0.3319897                  0              TRUE #> Akr1c19            0.1673342                  0              TRUE #> Aldh1a2            0.1827836                 50              TRUE #> ...                      ...                ...               ... #> Wnt5a               0.172300                  0              TRUE #> Wnt5b               0.104924                  0              TRUE #> Xist                0.120828                 50              TRUE #> Zfp444              0.118930                  0              TRUE #> Zfp57               0.130128                  0              TRUE #>                              permutations pvalPermutations FDRPermutations #>                             <NumericList>        <numeric>       <numeric> #> Acvr1                                  NA               NA              NA #> Acvr2a                                 NA               NA              NA #> Ahnak                                  NA               NA              NA #> Akr1c19                                NA               NA              NA #> Aldh1a2 0.0482154,0.0593701,0.0513777,...        0.0196078       0.0231579 #> ...                                   ...              ...             ... #> Wnt5a                                  NA               NA              NA #> Wnt5b                                  NA               NA              NA #> Xist       0.147309,0.134604,0.226559,...             0.46            0.46 #> Zfp444                                 NA               NA              NA #> Zfp57                                  NA               NA              NA #>         numberPermutationsEstimated globalLowerRangeEstimated #>                           <integer>                 <numeric> #> Acvr1                           150                  0.209573 #> Acvr2a                          100                  0.286168 #> Ahnak                            50                  0.922912 #> Akr1c19                          50                  0.767661 #> Aldh1a2                         150                  0.209573 #> ...                             ...                       ... #> Wnt5a                           150                  0.245981 #> Wnt5b                           150                  0.209573 #> Xist                            200                  1.092607 #> Zfp444                           50                  0.767661 #> Zfp57                          1100                  0.209573 #>         globalUpperRangeEstimated pvalEstimated FDREstimated #>                         <numeric>     <numeric>    <numeric> #> Acvr1                    0.286168    0.05333333    0.0698413 #> Acvr2a                   0.416245    0.29000000    0.3277397 #> Ahnak                    0.922912    0.01960784    0.0272727 #> Akr1c19                  0.767661    0.01960784    0.0272727 #> Aldh1a2                  0.286168    0.00662252    0.0196429 #> ...                           ...           ...          ... #> Wnt5a                    0.416245    0.00662252    0.0196429 #> Wnt5b                    0.286168    0.00662252    0.0196429 #> Xist                     1.163058    0.31000000    0.3456081 #> Zfp444                   0.767661    0.16000000    0.1885714 #> Zfp57                    3.171420    0.15090909    0.1791367 output_sorted <- slot(scHOT_spatial, \"scHOT_output\")[order(slot(scHOT_spatial,                                                                 \"scHOT_output\")$pvalEstimated),] topgenes <- rownames(output_sorted)[1:5]  reducedDim(scHOT_spatial, \"spatialCoords\") <- reducedDim(spe, \"spatialCoords\")[colnames(scHOT_spatial),]  for (topgene in topgenes) {   g_spe <- plotReducedDim(spe, \"spatialCoords\", colour_by = c(topgene), point_size = 1) +     coord_fixed()      g_scHOT <- plotReducedDim(scHOT_spatial, \"spatialCoords\", colour_by = c(topgene), point_size = 1,                            by_exprs_values = \"expression\") +     coord_fixed()      g_all <- g_scHOT + g_spe   print(g_all) } ## try some code"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"module-6-multi-sample-analysis","dir":"Articles","previous_headings":"","what":"Module 6: Multi-sample analysis","title":"Unlocking single cell spatial omics analyses with scdney","text":"following module examine can extract different spatial molecular features multi-sample datasets. features can used extract biological understanding. use MIBI-TOF breast cancer dataset.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"can-i-measure-if-two-cell-types-are-co-localised","dir":"Articles","previous_headings":"Module 6: Multi-sample analysis","what":"Can I measure if two cell types are co-localised?","title":"Unlocking single cell spatial omics analyses with scdney","text":"Kontextual part Statial package models spatial relationships cells context hierarchical cell lineage structures. assessing spatial relationships pairs cells context related cell types, Kontextual provides robust quantification cell type relationships invariant changes tissue structure. purposes using Kontextual define cell functions identified clusters cells, larger clusters represent “parent” cell population, finer sub-clusters representing “child” cell population particular function. example, CD4+ T cells highly specified function, may considered child larger parent population T cells. Kontextual thus aims quantify localisation patterns child population cells deviate spatial behaviour parent population, cellular function defines spatial localisation. Cell type hierarchy p53+ tumour cells exhibit different spatial behaviour compared tumour cells? quantify relationship? choose radius? quantitatively identify function-dictated spatial patterns across images? spatial patterns associated survival outcomes? key input Kontextual annotation cell type hierarchies. need organise cells present cell state populations clusters, e.g. different B cell types put vector called bcells. make lives easier, start defining . ’m happy talk use bioconductor package treekoR define hierarchies data driven way. examine image highlighted Keren et al. 2018 manuscript relationship two cell types depends parent cell population. image 6 Keren et al. dataset, can see p53+ tumour cells immune cells dispersed. However behaviour p53+ tumour cells placed context spatial behaviour broader parent population tumour cells, p53+ tumour cells immune appear localised.  Kontextual function accepts SingleCellExperiment object, single image, list images SingleCellExperiment object, gets passed cells argument. two cell types evaluated specified arguments. parent population must also specified parent argument, note parent cell population must include cell type. argument r specify radius cell relationship evaluated . Kontextual supports parallel processing, number cores can specified using cores argument. Kontextual can take single value multiple values argument test combinations arguments specified. can calculate relationships single radius. kontextCurve calculates L-function value Kontextual values range radii. kontextPlot plots values. points lie red line (expected pattern) localisation indicated radius, points lie red line dispersion indicated. seen following plot Kontextual able correctly identify localisation p53+ tumour cells immune cells example image certain range radii. original L-function able identify localisation value radii.  Alternatively pairwise cell relationships corresponding parents dataset can tested. data frame pairwise combinations can creating using parentCombinations function. function takes vector cells, well parent vectors set earlier. shown output data frame specifying , , parent arguments Kontextual. Rather specifying , , parent Kontextual, output parentCombinations can input Kontextual using parentDf argument, examine pairwise relationships dataset. chunk take significant amount time run (~20 minutes), demonstration results saved loaded . examine whether features obtained Statial associated patient outcomes groupings, can use colTest function SpicyR. understand survival outcomes differ significantly 2 patient groups, specify type = \"survival\" colTest. examine features associated patient survival using Kontextual values example. , survival data extracted kerenSPE converted survival object kerenSurv. addition , Kontextual results must converted data.frame wide matrix, can done using prepMatrix. Note, extract original L-function values, specify column = \"original\" prepMatrix. Finally, Kontextual matrix survival object passed colTest, type = \"survival\" obtain survival results. can see results CD8_T_cell__Keratin_Tumour__immune significant pairwise relationship contributes patient survival. relationship CD8 T cells Keratin+ Tumour cells, relative parent population immune cells. can see negative coefficient associated relationship, tells us decrease localisation CD8_T_cell Keratin+ Tumour leads poorer survival outcomes patients. can visualise association sing Kaplan-Meier curve. must first extract Kontextual values relationship across images. Next determine CD8 T cells Keratin+ Tumours relatively attracted avoiding image, comparing Kontextual value image median Kontextual value. Finally plot Kaplan-Meier curve using ggsurvfit package. shown , CD8 T cells Keratin+ Tumours relatively dispersed one another, patients tend worse survival outcomes.","code":"# Set up cell populations  tumour <- c(\"Keratin_Tumour\", \"Tumour\")  bcells <- c(\"B_cell\") tcells <- c(\"dn_T_cell\", \"CD4_T_cell\", \"CD8_T_cell\", \"Tregs\") myeloid <- c(\"Dc_or_Mono\", \"DC\", \"Mono_or_Neu\", \"Macrophages\", \"Other_Immune\", \"Neutrophils\")  endothelial <- c(\"Endothelial\") mesenchymal <- c(\"Mesenchymal\")  tissue <- c(endothelial, mesenchymal) immune <- c(bcells, tcells, myeloid, \"NK\")   all <- c(tumour, tissue, immune, \"Unidentified\") # Lets define a new cell type vector kerenSPE$cellTypeNew <- kerenSPE$cellType  # Select for all cells that express higher than baseline level of p53 p53Pos = assay(kerenSPE)[\"p53\",] > -0.300460  # Find p53+ tumour cells kerenSPE$cellTypeNew[kerenSPE$cellType %in% tumour] <- \"Tumour\" kerenSPE$cellTypeNew[p53Pos & kerenSPE$cellType %in% tumour] <- \"p53_Tumour\"  #Group all immune cells under the name \"Immune\"  kerenSPE$cellTypeNew[kerenSPE$cellType %in% immune] <- \"Immune\"   # Plot image 6  kerenSPE |>   colData() |>   as.data.frame() |>   filter(imageID == \"6\") |>   filter(cellTypeNew %in% c(\"Immune\", \"Tumour\", \"p53_Tumour\")) |>   arrange(cellTypeNew) |>   ggplot(aes(x = x, y = y, color = cellTypeNew)) +   geom_point(size = 1) +   scale_colour_manual(values = c(\"#505050\", \"#64BC46\",\"#D6D6D6\")) + guides(colour = guide_legend(title = \"Cell types\", override.aes = list(size=3))) p53_Kontextual <- Kontextual(   cells = kerenSPE,   image = 6,   r = 100,   from = \"Immune\",   to = \"p53_Tumour\",   parent = c(\"p53_Tumour\", \"Tumour\"),   cellType = \"cellTypeNew\" )  p53_Kontextual #>   imageID               test  original kontextual   r weightQuantile inhom edge #> 1       6 Immune__p53_Tumour -23.49524  -1.856852 100            0.8 FALSE TRUE #>   includeZeroCells window window.length #> 1             TRUE convex            NA curves <- kontextCurve(   cells = kerenSPE,   image = \"6\",   from = \"Immune\",   to = \"p53_Tumour\",   parent = c(\"p53_Tumour\", \"Tumour\"),   rs = seq(10, 510, 100),   cellType = \"cellTypeNew\",   cores = nCores )  kontextPlot(curves) # Get all relationships between cell types and their parents parentDf <- parentCombinations(   all = all,   tumour,   bcells,   tcells,   myeloid,   endothelial,   mesenchymal,   tissue,   immune ) # Running Kontextual on all relationships across all images. kerenKontextual <- Kontextual(   cells = kerenSPE,   parentDf = parentDf,   r = 50,   cores = nCores ) load(system.file(\"extdata\", \"kerenKontextual.rda\", package = \"ScdneySpatial\")) # Extracting survival data survData = kerenSPE |>     colData() |>      data.frame() |>      select(imageID, Survival_days_capped., event, RECURRENCE_LABEL) |>      unique()  # Creating survival vector kerenSurv = Surv(survData$Survival_days_capped, survData$event) names(kerenSurv) = survData$imageID # Converting Kontextual result into data matrix kontextMat = prepMatrix(kerenKontextual)  # Ensuring rownames of kontextMat match up with rownames of the survival vector  kontextMat = kontextMat[names(kerenSurv), ]  # Replace NAs with 0 kontextMat[is.na(kontextMat )] <- 0 # Running survival analysis survivalResults = spicyR::colTest(kontextMat, kerenSurv, type = \"survival\")   head(survivalResults) #>                                      coef se.coef   pval adjPval #> CD8_T_cell__Keratin_Tumour__immune -0.150   0.043 0.0006    0.21 #> CD4_T_cell__CD8_T_cell__tcells     -0.054   0.019 0.0039    0.51 #> CD4_T_cell__CD8_T_cell__immune     -0.040   0.015 0.0094    0.51 #> Endothelial__Mono_or_Neu__tissue   -0.031   0.012 0.0110    0.51 #> Other_Immune__NK__myeloid           0.045   0.018 0.0120    0.51 #> Endothelial__CD8_T_cell__tissue    -0.033   0.013 0.0120    0.51 #>                                                               cluster #> CD8_T_cell__Keratin_Tumour__immune CD8_T_cell__Keratin_Tumour__immune #> CD4_T_cell__CD8_T_cell__tcells         CD4_T_cell__CD8_T_cell__tcells #> CD4_T_cell__CD8_T_cell__immune         CD4_T_cell__CD8_T_cell__immune #> Endothelial__Mono_or_Neu__tissue     Endothelial__Mono_or_Neu__tissue #> Other_Immune__NK__myeloid                   Other_Immune__NK__myeloid #> Endothelial__CD8_T_cell__tissue       Endothelial__CD8_T_cell__tissue # Selecting most significant relationship survRelationship = kontextMat[[\"CD8_T_cell__Keratin_Tumour__immune\"]] survRelationship = ifelse(survRelationship > median(survRelationship), \"Localised\", \"Dispersed\")      # Plotting Kaplan-Meier curve survfit2(kerenSurv ~ survRelationship) |>     ggsurvfit() +     add_pvalue() +     ggtitle(\"CD8_T_cell__Keratin_Tumour__immune\")"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"are-there-changes-in-cell-states-associated-with-cell-localisation","dir":"Articles","previous_headings":"Module 6: Multi-sample analysis","what":"Are there changes in cell states associated with cell localisation?","title":"Unlocking single cell spatial omics analyses with scdney","text":"Changes cell phenotype can analytically framed change abundance gene protein within particular cell type. can analytically determine whether continuous changes occur cell’s proteomic transcriptomic signature changes occur spatial proximity another cell type. figures see expression marker increased cell type grows closer spatial proximity cell type B. can quantified scatterplot determine statistical significance. next section workshop, exploring analytical functionalities Statial can uncover continuous changes cell state.  identify specific marker changes distinct cell types increase decrease spatial proximity? Can repeat analysis across images identify global relationships? deal lateral cell spill ? cell type - marker relationships predictive survival outcomes? first step analysing changes calculate spatial proximity (getDistances) abundance (getAbundances) cell every cell type. values stored reducedDims slot SpatialExperiment object names distances abundances respectively. First, let’s examine effect observed earlier Kontextual. avoid redefining cell types ’ll examine distance p53-positive tumour cells macrophages context total keratin/tumour cells image 6. Statial provides two main functions assess relationship - calcStateChanges plotStateChanges. can use calcStateChanges examine relationship 2 cell types 1 marker specific image. Similar Kontextual, can specify two cell types arguments, marker interest marker argument. can appreciate fdr statistic relationship significant, negative coef, coefficient value, indicating expression p53 keratin/tumour cells decreases distance macrophages increases. Statial provides convenient function visualising relationship - plotStateChanges. Similar Kontextual calcStateChanges, can specify cell types evaluated arguments marker interest marker. analysis, can observe keratin/tumour cells closer group macrophages tend higher expression p53, observed first graph. relationship quantified second graph, showing overall decrease p53 expression keratin/tumour cells distance macrophages increase. results allow us essentially arrive result Kontextual, calculated localisation p53+ keratin/tumour cells macrophages wider context keratin/tumour cells.   Question information form analysis provide Kontextual ? observation localisation consistent across images? Can find interaction coefficient positive? .e. marker expression cell type rises distances increases cell type. Beyond looking single cell--cell interactions single image, can also look interactions across images. calcStateChanges function provided Statial can expanded exact purpose - specifying cell types, marker, image, calcStateChanges examine significant correlations distance marker expression across entire dataset. , ’ve calculated state changes across images case like play, first ’ll taking closer examination significant interactions found within image 6 Keren et al. dataset. image 6, majority top 10 significant interactions occur keratin/tumour cells immune population, many interactions appear involve HLA class ligand. can examine interactions plotStateChanges function. Taking closer examination relationship macrophages keratin/tumour HLA class expression, plot shows us clear visual correlation - macrophage density increases, keratin/tumour cells increase expression HLA class . Biologically, HLA Class ligand exists nucleated cells, tasked presenting internal cell antigens recognition immune system, marking aberrant cells destruction either CD8+ T cells NK cells.   Now, can take look top 10 significant results across images. Immediately, can appreciate couple interactions appear bit strange. One significant interactions occurs B cells CD4 T cells, CD4 T cells found increase CD20 expression close proximity B cells. Biologically, CD20 highly specific ligand B cells, healthy circumstances usually expressed T cells. potentially artefact calcStateChanges? can examine image plotStateChanges function, indeed observe apparent localisation B cells T cells. Question interactions think might make biological sense? relationship T cell CD20 expression B cell proximity occur across images? majority significant interactions occurring image 35? HINT: Configure parameters plotStateChanges examine significant interactions. look like artefacts?   T cells expressing CD20? brings us key limitation cell segmentation. Contamination, specifically known lateral marker spill , issue results cell’s marker expressions wrongly attributed another adjacent cell. issue arises incorrect segmentation components one cell wrongly determined belonging another cell. Alternatively, issue can arise antibodies used tag measure marker expressions latch properly cell interest, thereby resulting residual markers wrongly assigned belonging cell near intended target cell. important either correct account incorrect attribution markers modelling process. critical understanding whether significant cell-cell interactions detected artifact technical measurement errors driven spill real biological changes represent shift cell’s state.  circumvent problem, Statial provides function predicts probability cell particular cell type - calcContamination. calcContamination returns dataframe probabilities demarcating chance cell particular cell type. dataframe stored contaminations reducedDim slot SpatialExperiment object. also provides rfMainCellProb column, provides probability cell indeed cell type designated. E.g. cell designated CD8+ T cell, rfMainCellProb give 80% chance cell indeed CD8+ T cell, due contamination. can introduce probabilities covariates linear model setting contamination = TRUE parameter calcStateChanges function. However, perfect solution issue contamination. can see, despite factoring contamination linear model, correlation B cell density CD20 expression CD4+ T cells remains one significant interactions model. However, mean factoring contamination linear model ineffective. general, cell type specific markers CD68, CD45, CD20 change cells specific . Therefore, relationships detected significant involving cell type markers likely false positives treated purposes evaluation. Plotting relationship false positives true positives, ’d expect contamination correction greatest relationships detected significant.  , zoom ROC curve top 100 lowest p values occur, indeed see true positives false positives contamination correction.  Question can conclude ROC graphs? Similiar Kontextual, can run similar survival analysis using state changes results. , prepMatrix extracts coefficients, coef column stateChanges default. use t values instead, specify column = \"tval\" prepMatrix function. Question survival results distance abundance metrics? survival results change contamination correction? might survival results look /different distance abundance? state changes results, Macrophages__CD4_T_cell__CD138 significant pairwise relationship contributes patient survival. , relationship CD138 expression macrophages spatial proximity CD4 T cells change. positive coeffcient associated relationship tells us lower CD138 expression macrophages nearby CD4 T cells lead poorer survival outcomes patients.  Question coefficients interpreted? relationships makes sense? visualise representative images?","code":"kerenSPE <- getDistances(kerenSPE,                     maxDist = 200)  kerenSPE <- getAbundances(kerenSPE,                      r = 50) reducedDim(kerenSPE, \"abundances\")[is.na(reducedDim(kerenSPE, \"abundances\"))] <- 0 stateChanges <- calcStateChanges(   cells = kerenSPE,   type = \"distances\",   image = \"6\",   from = \"Keratin_Tumour\",   to = \"Macrophages\",   marker = \"p53\")  stateChanges #>   imageID primaryCellType otherCellType marker         coef      tval #> 1       6  Keratin_Tumour   Macrophages    p53 -0.001402178 -7.010113 #>           pval          fdr #> 1 2.868257e-12 2.868257e-12 p <- plotStateChanges(   cells = kerenSPE,   type = \"distances\",   image = \"6\",   from = \"Keratin_Tumour\",   to = \"Macrophages\",   marker = \"p53\",   size = 1,   shape = 19,   interactive = FALSE,   plotModelFit = FALSE,   method = \"lm\")  p$image p$scatter +    labs(y = \"p53 expression in Keratin_Tumour\",        x = \"Distance of Keratin_Tumour to Macrophages\") stateChanges <- calcStateChanges(   cells = kerenSPE,   type = \"distances\",   minCells = 100)  stateChanges |>    filter(imageID == 6) |>   head(n = 10) #>    imageID primaryCellType otherCellType       marker         coef      tval #> 1        6  Keratin_Tumour  Unidentified           Na  0.004218419  25.03039 #> 2        6  Keratin_Tumour   Macrophages  HLA_Class_1 -0.003823497 -24.69629 #> 3        6  Keratin_Tumour    CD4_T_cell  HLA_Class_1 -0.003582774 -23.87797 #> 4        6  Keratin_Tumour  Unidentified Beta.catenin  0.005893120  23.41953 #> 5        6  Keratin_Tumour    CD8_T_cell  HLA_Class_1 -0.003154544 -23.13804 #> 6        6  Keratin_Tumour    DC_or_Mono  HLA_Class_1 -0.003353834 -22.98944 #> 7        6  Keratin_Tumour      dn_T_CD3  HLA_Class_1 -0.003123446 -22.63197 #> 8        6  Keratin_Tumour        Tumour  HLA_Class_1  0.003684079  21.94265 #> 9        6  Keratin_Tumour    CD4_T_cell           Fe -0.003457338 -21.43550 #> 10       6  Keratin_Tumour    CD4_T_cell   phospho.S6 -0.002892457 -20.50767 #>             pval           fdr #> 1  6.971648e-127 3.357294e-123 #> 2  7.814253e-124 3.386756e-120 #> 3  1.745242e-116 5.602971e-113 #> 4  1.917245e-112 5.730680e-109 #> 5  5.444541e-110 1.498225e-106 #> 6  1.053130e-108 2.808827e-105 #> 7  1.237988e-105 2.980851e-102 #> 8  8.188258e-100  1.689930e-96 #> 9   1.287478e-95  2.325010e-92 #> 10  3.928912e-88  5.821606e-85 p <- plotStateChanges(   cells = kerenSPE,   type = \"distances\",   image = \"6\",   from = \"Keratin_Tumour\",   to = \"Macrophages\",   marker = \"HLA_Class_1\",   size = 1,   shape = 19,   interactive = FALSE,   plotModelFit = FALSE,   method = \"lm\")  p$image p$scatter +    labs(y = \"HLA_Class_1 expression in Keratin_Tumour\",        x = \"Distance of Keratin_Tumour to Macrophages\") stateChanges |> head(n = 10) #>        imageID primaryCellType otherCellType     marker         coef #> 69468       37     Endothelial        Tumour       Lag3 -0.001621517 #> 144255      11     Neutrophils            NK       CD56 -0.059936866 #> 16402       35      CD4_T_cell        B_cell       CD20 -0.029185750 #> 16498       35      CD4_T_cell    DC_or_Mono       CD20  0.019125946 #> 4891        35          B_cell    DC_or_Mono phospho.S6  0.005282065 #> 16507       35      CD4_T_cell    DC_or_Mono phospho.S6  0.004033218 #> 4885        35          B_cell    DC_or_Mono     HLA.DR  0.011120703 #> 5043        35          B_cell  Other_Immune          P  0.011182182 #> 16354       35      CD4_T_cell      dn_T_CD3       CD20  0.016349492 #> 4888        35          B_cell    DC_or_Mono     H3K9ac  0.005096632 #>                 tval          pval           fdr #> 69468  -4.916884e+14  0.000000e+00  0.000000e+00 #> 144255 -2.172437e+15  0.000000e+00  0.000000e+00 #> 16402  -4.057355e+01 7.019343e-282 4.056315e-277 #> 16498   4.053436e+01 1.891267e-281 8.196894e-277 #> 4891    4.041385e+01 5.306590e-278 1.839933e-273 #> 16507   3.472882e+01 4.519947e-219 1.305986e-214 #> 4885    3.415344e+01 8.401034e-212 2.080612e-207 #> 5043    3.414375e+01 1.056403e-211 2.289265e-207 #> 16354   3.391901e+01 1.219488e-210 2.349045e-206 #> 4888    3.399856e+01 3.266533e-210 5.662959e-206 p <- plotStateChanges(   cells = kerenSPE,   type = \"distances\",   image = \"35\",   from = \"CD4_T_cell\",   to = \"B_cell\",   marker = \"CD20\",   size = 1,   shape = 19,   interactive = FALSE,   plotModelFit = FALSE,   method = \"lm\")  p$image +    labs(y = \"CD20 expression in CD4_T_cell\",        x = \"Distance of B_cell to CD4_T_cell\") p$scatter kerenSPE <- calcContamination(kerenSPE)  stateChangesCorrected <- calcStateChanges(   cells = kerenSPE,   type = \"distances\",   minCells = 100,   contamination = TRUE)  stateChangesCorrected |> head(n = 20) #>        imageID primaryCellType otherCellType      marker         coef #> 69468       37     Endothelial        Tumour        Lag3 -0.001621517 #> 144255      11     Neutrophils            NK        CD56 -0.059936866 #> 16402       35      CD4_T_cell        B_cell        CD20 -0.025083624 #> 16498       35      CD4_T_cell    DC_or_Mono        CD20  0.016225621 #> 4891        35          B_cell    DC_or_Mono  phospho.S6  0.004397271 #> 16354       35      CD4_T_cell      dn_T_CD3        CD20  0.013867647 #> 16507       35      CD4_T_cell    DC_or_Mono  phospho.S6  0.003630126 #> 16357       35      CD4_T_cell      dn_T_CD3      HLA.DR  0.010356673 #> 85540        3  Keratin_Tumour            DC          Ca -0.013939833 #> 3697        28          B_cell            NK          Na -0.004462312 #> 4741        35          B_cell      dn_T_CD3      HLA.DR  0.009056688 #> 80974       20  Keratin_Tumour        Tumour HLA_Class_1  0.002965555 #> 82078       23  Keratin_Tumour  Unidentified HLA_Class_1  0.003188059 #> 5083        35          B_cell  Other_Immune  phospho.S6  0.004790796 #> 4885        35          B_cell    DC_or_Mono      HLA.DR  0.008889339 #> 5043        35          B_cell  Other_Immune           P  0.008256807 #> 5080        35          B_cell  Other_Immune      H3K9ac  0.005061792 #> 81737       21  Keratin_Tumour            DC Pan.Keratin -0.005993976 #> 4747        35          B_cell      dn_T_CD3  phospho.S6  0.003767236 #> 16363       35      CD4_T_cell      dn_T_CD3  phospho.S6  0.002966570 #>                 tval          pval           fdr #> 69468  -2.805747e+14  0.000000e+00  0.000000e+00 #> 144255 -2.265619e+15  0.000000e+00  0.000000e+00 #> 16402  -3.527286e+01 1.471188e-224 8.501655e-220 #> 16498   3.433303e+01 9.709612e-215 4.208219e-210 #> 4891    3.070953e+01 5.072179e-177 1.758656e-172 #> 16354   3.022328e+01 3.883378e-173 1.122057e-168 #> 16507   2.993728e+01 2.466479e-170 6.108516e-166 #> 16357   2.926312e+01 8.819909e-164 1.911307e-159 #> 85540  -2.961537e+01 7.578873e-163 1.459885e-158 #> 3697   -2.885743e+01 5.843841e-156 1.013106e-151 #> 4741    2.645733e+01 7.958696e-137 1.254312e-132 #> 80974   2.595077e+01 1.410980e-135 2.038431e-131 #> 82078   2.585593e+01 5.728680e-135 7.639547e-131 #> 5083    2.612732e+01 7.639758e-134 9.460367e-130 #> 4885    2.577910e+01 1.014405e-130 1.172402e-126 #> 5043    2.570769e+01 4.402113e-130 4.769772e-126 #> 5080    2.539252e+01 2.781691e-127 2.836719e-123 #> 81737  -2.470084e+01 8.985348e-127 8.654038e-123 #> 4747    2.518766e+01 1.793125e-125 1.636114e-121 #> 16363   2.512759e+01 2.089201e-125 1.810951e-121 cellTypeMarkers <- c(\"CD3\", \"CD4\", \"CD8\", \"CD56\", \"CD11c\", \"CD68\", \"CD45\", \"CD20\")  values = c(\"blue\", \"red\") names(values) <- c(\"None\", \"Corrected\")  df <- rbind(data.frame(TP =cumsum(stateChanges$marker %in% cellTypeMarkers), FP = cumsum(!stateChanges$marker %in% cellTypeMarkers), type = \"None\"),             data.frame(TP =cumsum(stateChangesCorrected$marker %in% cellTypeMarkers), FP = cumsum(!stateChangesCorrected$marker %in% cellTypeMarkers), type = \"Corrected\"))  ggplot(df, aes(x = TP, y = FP, colour = type)) + geom_line()+ labs(y = \"Cell state marker\", x = \"Cell type marker\") + scale_colour_manual(values = values) ggplot(df, aes(x = TP, y = FP, colour = type)) + geom_line()+ xlim(0,100) + ylim(0,1000)+ labs(y = \"Cell state marker\", x = \"Cell type marker\") + scale_colour_manual(values = values) # Preparing features for Statial stateMat <- prepMatrix(stateChanges)  # Ensuring rownames of stateMat match up with rownames of the survival vector stateMat <- stateMat[names(kerenSurv), ]  # Remove some very small values stateMat <- stateMat[,colMeans(abs(stateMat)>0.0001)>.8]  survivalResults <- colTest(stateMat, kerenSurv, type = \"survival\")  head(survivalResults) #>                                          coef se.coef    pval adjPval #> Macrophages__CD4_T_cell__CD138            440     110 8.1e-05   0.054 #> Macrophages__Other_Immune__HLA_Class_1   -500     170 2.9e-03   0.620 #> Keratin_Tumour__Mesenchymal__dsDNA       -930     330 4.9e-03   0.620 #> Keratin_Tumour__CD8_T_cell__Keratin6     -220      80 5.2e-03   0.620 #> Keratin_Tumour__Mono_or_Neu__Pan.Keratin -260      94 6.0e-03   0.620 #> Macrophages__Other_Immune__CD4           -480     180 7.6e-03   0.620 #>                                                                           cluster #> Macrophages__CD4_T_cell__CD138                     Macrophages__CD4_T_cell__CD138 #> Macrophages__Other_Immune__HLA_Class_1     Macrophages__Other_Immune__HLA_Class_1 #> Keratin_Tumour__Mesenchymal__dsDNA             Keratin_Tumour__Mesenchymal__dsDNA #> Keratin_Tumour__CD8_T_cell__Keratin6         Keratin_Tumour__CD8_T_cell__Keratin6 #> Keratin_Tumour__Mono_or_Neu__Pan.Keratin Keratin_Tumour__Mono_or_Neu__Pan.Keratin #> Macrophages__Other_Immune__CD4                     Macrophages__Other_Immune__CD4 # Selecting the most significant relationship survRelationship = stateMat[[\"Macrophages__CD4_T_cell__CD138\"]] survRelationship = ifelse(survRelationship > median(survRelationship), \"Higher expressed in close cells\", \"Lower expressed in close cells\")      # Plotting Kaplan-Meier curve survfit2(kerenSurv ~ survRelationship) |>     ggsurvfit() +     add_pvalue() +     ggtitle(\"Macrophages__CD4_T_cell__CD138\")"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"how-do-we-generate-a-molecular-representation-for-each-individual","dir":"Articles","previous_headings":"Module 6: Multi-sample analysis","what":"How do we generate a molecular representation for each individual?","title":"Unlocking single cell spatial omics analyses with scdney","text":"next section workshop dedicated scFeatures - straightforward package generating suite molecular representations regarding patient, taking matrix proteins x cells input. molecular representation interpretable hence facilitates downstream analysis individual. general, scFeatures generates features across six categories representing different molecular views cellular characteristics. include: cell type proportions cell type specific gene expressions cell type specific pathway expressions cell type specific cell-cell interaction (CCI) scores overall aggregated gene expressions spatial metrics different types features constructed enable comprehensive multi-view understanding individual matrix spot x cells. default, function generate total 13 different types features (feature_types) shown store list. generated feature types stored matrix samples x features. different ways can use scFeatures generate molecular representations individuals requires following information spatial data. data, sample, X coordinates, Y coordinates, feature_types, type total 13 different types features (feature_types) can choose generate. argument type refers type input data . either scrna (single-cell RNA-sequencing data), spatial_p (spatial proteomics data), spatial_t (single cell spatial data). Suppose interested determining proportion cell type individual within region. necessary specify type = spatial_p reflect spatial proteomics data feature_types = proportion_raw indicate intend calculate cell type proportion region-specific sub-cell types. output scFeatures, scfeatures_result, list 13 dataframes, represent different molecular feature patient. , give example visualisation raw cell type proportions patient.  matrix <- assay(kerenSPE, \"intensities\") |> .matrix() sample <- kerenSPE$imageID celltype <- kerenSPE$cellType spatialCoords <- lapply(seq_len(ncol(spatialCoords(kerenSPE))), function() spatialCoords(kerenSPE)[,])   scfeatures_result <- scFeatures(matrix, type = \"spatial_p\",                                 sample = sample, celltype = celltype, spatialCoords = spatialCoords,                                 ncores = 32) load(system.file(\"extdata\", \"scfeaturesResult.rda\", package = \"ScdneySpatial\")) data.frame(scfeatures_result[[1]][1:5, 1:5]) feature <- scfeatures_result$proportion_raw  feature$patient <- unlist(lapply(strsplit(rownames(feature), \"_cond_\"), `[`, 1)) feature$condition <- unlist(lapply(strsplit(rownames(feature), \"_cond_\"), `[`, 2))  feature <- .data.frame(melt(feature, id=c(\"patient\", \"condition\")))  ggplot(feature , aes(x = patient , y = value , fill = variable)) +      geom_bar(stat=\"identity\") +    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +    ggtitle(\"Proportion raw feature\")","code":"##  [1] \"proportion_raw\"       \"proportion_logit\"     \"proportion_ratio\"     ##  [4] \"gene_mean_celltype\"   \"gene_prop_celltype\"   \"gene_cor_celltype\"    ##  [7] \"gene_mean_bulk\"       \"gene_prop_bulk\"       \"gene_cor_bulk\"        ## [10] \"L_stats\"              \"celltype_interaction\" \"morans_I\"             ## [13] \"nn_correlation\" #>        B_cell  CD4_T_cell CD8_T_cell           DC  DC_or_Mono #> 1 0.221985678 0.047029224 0.03348171 0.0003870718 0.034062319 #> 2 0.000660502 0.006935271 0.08091149 0.0122192867 0.002972259 #> 3 0.067616785 0.077751386 0.07854315 0.0057007126 0.068725257 #> 4 0.049525817 0.110341713 0.04576246 0.0003010688 0.068944754 #> 5 0.000554939 0.047169811 0.09822420 0.0005549390 0.061598224"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"can-i-identify-distinct-neighbourhoods-or-regions-of-cells-in-my-images","dir":"Articles","previous_headings":"Module 6: Multi-sample analysis","what":"Can I identify distinct neighbourhoods or regions of cells in my images?","title":"Unlocking single cell spatial omics analyses with scdney","text":"can cluster areas similar spatial interactions identify regions using lisaClust package Bioconductor. set k = 5 identify 5 regions. ways can check region clustering worked effectively? One way can use hatchingPlot function visualise regions identified lisaClust.  can appreciate regions separated nicely image 5, region 1 clearly tumour region, region 5 non-tumour region, region 3 tumour-immune interaction region. can also use regionMap function get quantitative determination region represents, look cell types encountered regions.  One feature might interested exploring examine molecular profile region cells within region. Statial provides functionality identify average marker expression given cell type given region, using getMarkerMeans function. Similar analysis , features can also used survival analysis. set.seed(51773)  # Preparing features lisaClust kerenSPE <- lisaClust::lisaClust(   cells = kerenSPE,   k = 5,   BPPARAM = BPPARAM) # Use hatching visualise regions cell types. lisaClust::hatchingPlot(   kerenSPE,   useImages = \"5\" ) regionMap(kerenSPE) Question cellTypeRegionMeans <- getMarkerMeans(kerenSPE,                               imageID = \"imageID\",                               cellType = \"cellType\",                               region = \"region\")  survivalResults = colTest(cellTypeRegionMeans[names(kerenSurv),], kerenSurv, type = \"survival\")  head(survivalResults) ways identify “right” number regions? Can think ways generate additional features using regions?","code":"#>                                    coef se.coef    pval adjPval #> Si__Unidentified__region_4         -3.4    1.00 0.00073    0.47 #> HLA_Class_1__Macrophages__region_4 -1.7    0.50 0.00085    0.47 #> CD45RO__dn_T_CD3__region_4         -2.4    0.73 0.00089    0.47 #> HLA_Class_1__Neutrophils__region_4 -1.7    0.51 0.00110    0.47 #> CD209__CD8_T_cell__region_1        10.0    3.20 0.00140    0.47 #> HLA_Class_1__Mono_or_Neu__region_1 -1.6    0.50 0.00150    0.47 #>                                                               cluster #> Si__Unidentified__region_4                 Si__Unidentified__region_4 #> HLA_Class_1__Macrophages__region_4 HLA_Class_1__Macrophages__region_4 #> CD45RO__dn_T_CD3__region_4                 CD45RO__dn_T_CD3__region_4 #> HLA_Class_1__Neutrophils__region_4 HLA_Class_1__Neutrophils__region_4 #> CD209__CD8_T_cell__region_1               CD209__CD8_T_cell__region_1 #> HLA_Class_1__Mono_or_Neu__region_1 HLA_Class_1__Mono_or_Neu__region_1"},{"path":"https://sydneybiox.github.io/ScdneySpatial/articles/workshop_material.html","id":"module-7-patient-classification","dir":"Articles","previous_headings":"","what":"Module 7: Patient classification","title":"Unlocking single cell spatial omics analyses with scdney","text":"Finally demonstrate can use Bioconductor package ClassifyR perform patient classification features generated Statial scFeatures. addition , also calculate cell type proportions region proportions using getProp function spicyR. perform 5 fold cross validation 20 repeats, using CoxPH model survival classification. prepare metrics classification, first must convert dataframes matrix format. can accomplished, earlier, prepMatrix function Statial. generated matrices Kontextual distance metric SpatioMark earlier, now generating matrices SpatioMark corrected distance metric, abundance metrics. can also prepare metric region proportions, look whether percentage area region occupies image capable predicting survival. compile matrices list. scFeatures conveniently provides metrics part list matrices already, allowing us easily combine Statial metrics scFeatures 1 list matrices. input list crossValidate function ClassifyR, specifying survival object created earlier, 5 folds cross validation 20 repeats. also using feature selection algorithm selecting 10 features metric. Next, use performancePlot function assess C-index repeat 5-fold cross-validation.  Unfortunately, spatial metrics outperform simpler metrics generated scFeatures, particularly gene_mean_bulk, simply produces matrix describing average gene expression marker patient. examine another variable might interest, used recurrence another outcome determine whether spatial metrics uncover signal. , using performancePlot, time recurrence, found better performance select spatial metrics.  Questions Discuss among table spatial metrics might perform better recurrence compared survival.","code":"## Distances Corrected Matrix stateMatCorDist <- prepMatrix(stateChangesCorrected) stateMatCorDist <- stateMatCorDist[names(kerenSurv), ] stateMatCorDist[is.na(stateMatCorDist)] <- 0 # Remove some very small values stateMatCorDist <- stateMatCorDist[,colMeans(abs(stateMatCorDist)>0.0001)>.8]  reducedDim(kerenSPE, \"abundances\")[is.na(reducedDim(kerenSPE, \"abundances\"))] <- 0 ## Abundances stateChangesAbund <- calcStateChanges(   cells = kerenSPE,   type = \"abundances\",   minCells = 100)  stateMatAbund <- prepMatrix(stateChangesAbund) stateMatAbund <- stateMatAbund[names(kerenSurv), ] stateMatAbund[is.na(stateMatAbund)] <- 0 # Remove some very small values stateMatAbund <- stateMatAbund[,colMeans(abs(stateMatAbund)>0.0001)>.8]  ## Abundances Corrected stateChangesCorrectedAbund <- calcStateChanges(   cells = kerenSPE,   type = \"abundances\",   minCells = 100,   contamination = TRUE)  stateMatCorAbund <- prepMatrix(stateChangesCorrectedAbund) stateMatCorAbund <- stateMatCorAbund[names(kerenSurv), ] stateMatCorAbund[is.na(stateMatCorAbund)] <- 0 # Remove some very small values stateMatCorAbund <- stateMatCorAbund[,colMeans(abs(stateMatCorAbund)>0.0001)>.8]  ## Region proportions regionProp <- getProp(kerenSPE,                         feature = \"region\",                        imageID = \"imageID\") statialFeatureList <- list(`SpatioMark Distances` = stateMat,                            `SpatioMark Corrected Distances` = stateMatCorDist,                            `SpatioMark Abundances` = stateMatAbund,                            `SpatioMark Corrected Abundances` = stateMatCorAbund,                            `Kontextual` = kontextMat,                            `Region Marker Means` = cellTypeRegionMeans,                            `Region Proportions` = regionProp)  set.seed(51773)  featureList <- c(statialFeatureList, scfeatures_result) featureList <- lapply(featureList, function(x)x[names(kerenSurv),])  kerenCV = crossValidate(   measurements = featureList,   outcome = kerenSurv,   classifier = \"CoxPH\",   selectionMethod  = \"CoxPH\",   nFolds = 5,   nFeatures = 10,   nRepeats = 20,   nCores = nCores ) load(system.file(\"extdata\", \"featureList.rda\", package = \"ScdneySpatial\")) load(system.file(\"extdata\", \"kerenCV.rda\", package = \"ScdneySpatial\")) performancePlot(kerenCV,   characteristicsList = list(x = \"Assay Name\"),   orderingList = list(\"Assay Name\" = c(names(statialFeatureList), names(scfeatures_result)))) +    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +   geom_rect(aes(xmin = 0, xmax = 5.5, ymin = -Inf, ymax = Inf), fill = \"red\", alpha = 0.2) +   geom_rect(aes(xmin = 5.5, xmax = 7.5, ymin = -Inf, ymax = Inf), fill = \"yellow\", alpha = 0.2) +   geom_rect(aes(xmin = 7.5, xmax = 16.5, ymin = -Inf, ymax = Inf), fill = \"blue\", alpha = 0.2) +   geom_rect(aes(xmin = 16.5, xmax = 21, ymin = -Inf, ymax = Inf), fill = \"green\", alpha = 0.2) outcome <- survData$RECURRENCE_LABEL names(outcome) <- survData$imageID  outcome <- factor(outcome)  featureList <- lapply(featureList, function(x)x[names(outcome),])  kerenCV_recurrence = crossValidate(   measurements = featureList,   outcome = outcome,   classifier = \"elasticNetGLM\",   selectionMethod = \"auto\",   nFolds = 5,   nFeatures = 10,   nRepeats = 20,   nCores = nCores ) load(system.file(\"extdata\", \"recurrenceCV.rda\", package = \"ScdneySpatial\")) performancePlot(kerenCV_recurrence,   characteristicsList = list(x = \"Assay Name\"),   orderingList = list(\"Assay Name\" = c(names(statialFeatureList), names(scfeatures_result)))) +    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1)) +   geom_rect(aes(xmin = 0, xmax = 5.5, ymin = -Inf, ymax = Inf), fill = \"red\", alpha = 0.2) +   geom_rect(aes(xmin = 5.5, xmax = 7.5, ymin = -Inf, ymax = Inf), fill = \"yellow\", alpha = 0.2) +   geom_rect(aes(xmin = 7.5, xmax = 16.5, ymin = -Inf, ymax = Inf), fill = \"blue\", alpha = 0.2) +   geom_rect(aes(xmin = 16.5, xmax = 21, ymin = -Inf, ymax = Inf), fill = \"green\", alpha = 0.2) sessionInfo() #> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Debian GNU/Linux 12 (bookworm) #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.21.so;  LAPACK version 3.11.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: Australia/Sydney #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] lubridate_1.9.3                 forcats_1.0.0                   #>  [3] stringr_1.5.1                   purrr_1.0.2                     #>  [5] readr_2.1.4                     tibble_3.2.1                    #>  [7] tidyverse_2.0.0                 ttservice_0.3.8                 #>  [9] tidyr_1.3.0                     dplyr_1.1.4                     #> [11] tidySingleCellExperiment_1.12.0 scater_1.30.1                   #> [13] scuttle_1.12.0                  reshape_0.8.9                   #> [15] plotly_4.10.3                   glmnet_4.1-8                    #> [17] Matrix_1.6-3                    ggsurvfit_1.0.0                 #> [19] ggplot2_3.4.4                   batchelor_1.18.0                #> [21] cytomapper_1.14.0               EBImage_4.44.0                  #> [23] Statial_1.4.5                   spicyR_1.14.1                   #> [25] simpleSeg_1.4.0                 scHOT_1.14.0                    #> [27] scFeatures_0.99.27              scClassify_1.14.0               #> [29] lisaClust_1.10.1                FuseSOM_1.4.0                   #> [31] ClassifyR_3.6.2                 survival_3.5-7                  #> [33] BiocParallel_1.36.0             MultiAssayExperiment_1.28.0     #> [35] generics_0.1.3                  SpatialDatasets_1.0.0           #> [37] BumpyMatrix_1.10.0              STexampleData_1.10.0            #> [39] SpatialExperiment_1.12.0        SingleCellExperiment_1.24.0     #> [41] SummarizedExperiment_1.32.0     Biobase_2.62.0                  #> [43] GenomicRanges_1.54.1            GenomeInfoDb_1.38.1             #> [45] IRanges_2.36.0                  S4Vectors_0.40.2                #> [47] MatrixGenerics_1.14.0           matrixStats_1.1.0               #> [49] ExperimentHub_2.10.0            AnnotationHub_3.10.0            #> [51] BiocFileCache_2.10.1            dbplyr_2.4.0                    #> [53] BiocGenerics_0.48.1             #>  #> loaded via a namespace (and not attached): #>   [1] igraph_1.5.1                  graph_1.80.0                  #>   [3] fpc_2.2-10                    zlibbioc_1.48.0               #>   [5] tidyselect_1.2.0              bit_4.0.5                     #>   [7] lattice_0.22-5                rjson_0.2.21                  #>   [9] blob_1.2.4                    S4Arrays_1.2.0                #>  [11] parallel_4.3.1                png_0.1-8                     #>  [13] ResidualMatrix_1.12.0         cli_3.6.1                     #>  [15] ggplotify_0.1.2               ProtGenerics_1.34.0           #>  [17] multtest_2.58.0               goftest_1.2-3                 #>  [19] pkgdown_2.0.7                 textshaping_0.3.7             #>  [21] BiocIO_1.12.0                 kernlab_0.9-32                #>  [23] bluster_1.12.0                BiocNeighbors_1.20.0          #>  [25] uwot_0.1.16                   curl_5.1.0                    #>  [27] mime_0.12                     evaluate_0.23                 #>  [29] tiff_0.1-11                   V8_4.4.0                      #>  [31] stringi_1.8.2                 backports_1.4.1               #>  [33] desc_1.4.2                    FCPS_1.3.4                    #>  [35] lmerTest_3.1-3                XML_3.99-0.16                 #>  [37] httpuv_1.6.12                 flexmix_2.3-19                #>  [39] AnnotationDbi_1.64.1          magrittr_2.0.3                #>  [41] DataVisualizations_1.3.2      rappdirs_0.3.3                #>  [43] splines_4.3.1                 mclust_6.0.1                  #>  [45] jpeg_0.1-10                   ggraph_2.1.0                  #>  [47] ggbeeswarm_0.7.2              DBI_1.1.3                     #>  [49] terra_1.7-55                  HDF5Array_1.30.0              #>  [51] genefilter_1.84.0             jquerylib_0.1.4               #>  [53] withr_2.5.2                   class_7.3-22                  #>  [55] systemfonts_1.0.5             rprojroot_2.0.4               #>  [57] GSEABase_1.64.0               tidygraph_1.2.3               #>  [59] rtracklayer_1.62.0            BiocManager_1.30.22           #>  [61] htmlwidgets_1.6.3             fs_1.6.3                      #>  [63] biomaRt_2.58.0                segmented_1.6-4               #>  [65] ggrepel_0.9.4                 princurve_2.1.6               #>  [67] Cepo_1.8.0                    labeling_0.4.3                #>  [69] SparseArray_1.2.2             DEoptimR_1.1-3                #>  [71] ranger_0.16.0                 SingleCellSignalR_1.14.0      #>  [73] mixtools_2.0.0                diptest_0.76-0                #>  [75] annotate_1.80.0               minpack.lm_1.2-4              #>  [77] raster_3.6-26                 XVector_0.42.0                #>  [79] knitr_1.45                    nnls_1.5                      #>  [81] AUCell_1.24.0                 timechange_0.2.0              #>  [83] foreach_1.5.2                 fansi_1.0.5                   #>  [85] patchwork_1.1.3               caTools_1.18.2                #>  [87] grid_4.3.1                    data.table_1.14.8             #>  [89] rhdf5_2.46.0                  vegan_2.6-4                   #>  [91] R.oo_1.25.0                   psych_2.3.9                   #>  [93] irlba_2.3.5.1                 gridGraphics_0.5-1            #>  [95] ellipsis_0.3.2                lazyeval_0.2.2                #>  [97] yaml_2.3.7                    scattermore_1.2               #>  [99] BiocVersion_3.18.1            crayon_1.5.2                  #> [101] RcppAnnoy_0.0.21              RColorBrewer_1.1-3            #> [103] tweenr_2.0.2                  later_1.3.1                   #> [105] codetools_0.2-19              GlobalOptions_0.1.2           #> [107] KEGGREST_1.42.0               Rtsne_0.16                    #> [109] shape_1.4.6                   limma_3.58.1                  #> [111] Rsamtools_2.18.0              filelock_1.0.2                #> [113] pkgconfig_2.0.3               xml2_1.3.5                    #> [115] ggpubr_0.6.0                  GenomicAlignments_1.38.0      #> [117] spatstat.sparse_3.0-3         ape_5.7-1                     #> [119] viridisLite_0.4.2             xtable_1.8-4                  #> [121] coop_0.6-3                    fastcluster_1.2.3             #> [123] highr_0.10                    car_3.1-2                     #> [125] plyr_1.8.9                    httr_1.4.7                    #> [127] prabclus_2.3-3                tools_4.3.1                   #> [129] beeswarm_0.4.0                broom_1.0.5                   #> [131] nlme_3.1-163                  MatrixModels_0.5-3            #> [133] crosstalk_1.2.1               lme4_1.1-35.1                 #> [135] digest_0.6.33                 permute_0.9-7                 #> [137] numDeriv_2016.8-1.1           farver_2.1.1                  #> [139] tzdb_0.4.0                    AnnotationFilter_1.26.0       #> [141] reshape2_1.4.4                yulab.utils_0.1.0             #> [143] viridis_0.6.4                 glue_1.6.2                    #> [145] cachem_1.0.8                  hopach_2.62.0                 #> [147] polyclip_1.10-6               proxyC_0.3.4                  #> [149] Biostrings_2.70.1             profileModel_0.6.1            #> [151] mnormt_2.1.1                  statmod_1.5.0                 #> [153] concaveman_1.1.0              ragg_1.2.6                    #> [155] ScaledMatrix_1.10.0           carData_3.0-5                 #> [157] minqa_1.2.6                   dqrng_0.3.2                   #> [159] utf8_1.2.4                    graphlayouts_1.0.2            #> [161] gtools_3.9.5                  analogue_0.17-6               #> [163] ggsignif_0.6.4                gridExtra_2.3                 #> [165] shiny_1.8.0                   GSVA_1.50.0                   #> [167] GenomeInfoDbData_1.2.11       R.utils_2.12.3                #> [169] rhdf5filters_1.14.0           RCurl_1.98-1.13               #> [171] memoise_2.0.1                 rmarkdown_2.25                #> [173] pheatmap_1.0.12               scales_1.3.0                  #> [175] R.methodsS3_1.8.2             svglite_2.1.2                 #> [177] spatstat.data_3.0-3           rstudioapi_0.15.0             #> [179] EnsDb.Mmusculus.v79_2.99.0    cluster_2.1.4                 #> [181] msigdbr_7.5.1                 spatstat.utils_3.0-4          #> [183] hms_1.1.3                     munsell_0.5.0                 #> [185] cowplot_1.1.1                 scam_1.2-14                   #> [187] colorspace_2.1-0              rlang_1.1.2                   #> [189] EnsDb.Hsapiens.v79_2.99.0     DelayedMatrixStats_1.24.0     #> [191] sparseMatrixStats_1.14.0      shinydashboard_0.7.2          #> [193] ggforce_0.4.1                 circlize_0.4.15               #> [195] mgcv_1.9-0                    xfun_0.41                     #> [197] modeltools_0.2-23             iterators_1.0.14              #> [199] abind_1.4-5                   interactiveDisplayBase_1.40.0 #> [201] Rhdf5lib_1.24.0               bitops_1.0-7                  #> [203] fftwtools_0.9-11              promises_1.2.1                #> [205] RSQLite_2.3.3                 DelayedArray_0.28.0           #> [207] proxy_0.4-27                  compiler_4.3.1                #> [209] prettyunits_1.2.0             boot_1.3-28.1                 #> [211] beachmat_2.18.0               Rcpp_1.0.11                   #> [213] edgeR_4.0.2                   BiocSingular_1.18.0           #> [215] tensor_1.5                    MASS_7.3-60                   #> [217] progress_1.2.2                ggupset_0.3.0                 #> [219] babelgene_22.9                spatstat.random_3.2-2         #> [221] R6_2.5.1                      fastmap_1.1.1                 #> [223] rstatix_0.7.2                 vipor_0.4.5                   #> [225] ensembldb_2.26.0              nnet_7.3-19                   #> [227] rsvd_1.0.5                    gtable_0.3.4                  #> [229] KernSmooth_2.23-22            deldir_2.0-2                  #> [231] htmltools_0.5.7               RcppParallel_5.1.7            #> [233] bit64_4.0.5                   spatstat.explore_3.2-5        #> [235] lifecycle_1.0.4               nloptr_2.0.3                  #> [237] restfulr_0.0.15               sass_0.4.7                    #> [239] vctrs_0.6.5                   robustbase_0.99-0             #> [241] spatstat.geom_3.2-7           scran_1.30.0                  #> [243] sp_2.1-2                      bslib_0.6.1                   #> [245] pillar_1.9.0                  GenomicFeatures_1.54.1        #> [247] gplots_3.1.3                  magick_2.8.1                  #> [249] metapod_1.10.0                locfit_1.5-9.8                #> [251] jsonlite_1.8.7                brglm_0.7.2                   #> [253] svgPanZoom_0.3.4"},{"path":"https://sydneybiox.github.io/ScdneySpatial/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Farhan Ameen. Author, maintainer. Alex Qin. Author. Nick Robertson. Author. Shila Ghazanfar. Author. Ellis Patrick. Author.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ameen F, Qin , Robertson N, Ghazanfar S, Patrick E (2023). ScdneySpatial: Unlocking single cell spatial omics analyses scdney. R package version 2.0.0, https://sydneybiox.github.io/ScdneySpatial/.","code":"@Manual{,   title = {ScdneySpatial: Unlocking single cell spatial omics analyses with scdney},   author = {Farhan Ameen and Alex Qin and Nick Robertson and Shila Ghazanfar and Ellis Patrick},   year = {2023},   note = {R package version 2.0.0},   url = {https://sydneybiox.github.io/ScdneySpatial/}, }"},{"path":"https://sydneybiox.github.io/ScdneySpatial/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"ScdneySpatial","text":"Understanding interplay different types cells immediate environment critical understanding mechanisms cells function context human diseases. Recent advances high dimensional situ cytometry technologies fundamentally revolutionized ability observe complex cellular relationships providing unprecedented characterisation cellular heterogeneity tissue environment.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/index.html","id":"description","dir":"","previous_headings":"","what":"Description","title":"ScdneySpatial","text":"tutorial introduce analytical framework analysing data high dimensional spatial omics technologies , CODEX, CycIF, IMC High Definition Spatial Transcriptomics. framework makes use functionality Bioconductor packages simpleSeg, scHot, FuseSOM, spicyR, listClust, statial, scFeatures ClassifyR. end tutorial attendees able implement assess key steps spatial analysis pipeline including cell segmentation, feature normalisation, cell type identification, microenvironment cell-state characterisation, spatial hypothesis testing patient classification. Understanding key steps provide attendees core skills needed interrogate comprehensive spatial information generated exciting new technologies.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/index.html","id":"pre-requisites","dir":"","previous_headings":"Description","what":"Pre-requisites","title":"ScdneySpatial","text":"expected students : basic knowledge R syntax, familiarity SingleCellExperiment /SpatialExperiment objects, workshop provide -depth description cell-resolution spatial omics technologies.","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/index.html","id":"time-outline","dir":"","previous_headings":"Description","what":"Time outline","title":"ScdneySpatial","text":"expected timing workshop:","code":""},{"path":"https://sydneybiox.github.io/ScdneySpatial/index.html","id":"learning-objectives","dir":"","previous_headings":"Description","what":"Learning objectives","title":"ScdneySpatial","text":"Understand visualise spatial omics datasets. Identify key biological questions can addressed technologies spatial analysis. Understand key analytical steps involved spatial omics analysis, perform steps using R. Evaluate performance data normalisation cell segmentation. Understand generate individual feature representations spatial omics data. Develop appreciation assess performance classification models. Perform disease outcome prediction using feature representation robust classification framework.","code":""}]

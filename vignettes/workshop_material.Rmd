---
title: "Unlocking single cell spatial omics analyses with scdney"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Unlocking spatial omics analysis with scdney}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  #collapse = TRUE,
  comment = "#>",
  cache = TRUE,
  message = FALSE,
  warning = FALSE
)
```


```{=html}
<style>
.question {
  padding: 1em;
  background: lightcyan;
  color: black;
  border-radius: 10px;
}
</style>
```

Farhan Ameen$^{1,2,3}$, Shila Ghazanfar$^{2,3}$, Ellis
Patrick$^{1,2,3}$.

$^1$ Westmead Institute for Medical Research, University of Sydney,
Australia\
$^2$ Sydney Precision Data Science Centre, University of Sydney,
Australia\
$^3$ School of Mathematics and Statistics, University of Sydney,
Australia

<br/> Contact: ellis.patrick\@sydney.edu.au

## Overview

Understanding the interplay between different types of cells and their
immediate environment is critical for understanding the mechanisms of
cells themselves and their function in the context of human diseases.
Recent advances in high dimensional in situ cytometry technologies have
fundamentally revolutionized our ability to observe these complex
cellular relationships providing an unprecedented characterisation of
cellular heterogeneity in a tissue environment.

### Description

In this tutorial we will introduce an analytical framework for analysing
data from high dimensional spatial omics technologies such as, CODEX,
CycIF, IMC and High Definition Spatial Transcriptomics. This framework
makes use of functionality from our Bioconductor packages simpleSeg,
FuseSOM, scClassify, scHot, spicyR, listClust, statial, scFeatures and
ClassifyR. By the end of this tutorial attendees will be able to
implement and assess some of the key steps of a spatial analysis
pipeline including cell segmentation, feature normalisation, cell type
identification, microenvironment and cell-state characterisation,
spatial hypothesis testing and patient classification. Understanding
these key steps will provide attendees with the core skills needed to
interrogate the comprehensive spatial information generated by these
exciting new technologies.

### Pre-requisites

It is expected that students will have:

-   basic knowledge of R syntax,
-   familiarity with SingleCellExperiment and/or SpatialExperiment
    objects, and
-   this workshop will not provide an in-depth description of
    cell-resolution spatial omics technologies.

### *R* / *Bioconductor* packages used

Several single cell R packages will be used from the scdney package, for
more information visit: <https://sydneybiox.github.io/scdney/>

### Time outline

| Activity                               | Time   |
|----------------------------------------|--------|
| Data visualisation & cell segmentation | 1h 30m |
| Cell type clustering & classification  | 1h 30m |
| Spatial analysis & feature generation  | 2h     |
| Patient Classification                 | 1h 30m |

### Learning objectives

-   Understand and visualise spatial omics datasets.
-   Identify key biological questions that can be addressed with these
    technologies and spatial analysis.
-   Understand the key analytical steps involved in spatial omics
    analysis, and perform these steps using R.
-   Evaluate the performance of data normalisation and cell
    segmentation.
-   Understand and generate individual feature representations from
    spatial omics data.
-   Develop appreciation on how to assess performance of classification
    models.
-   Perform disease outcome prediction using the feature representation
    and robust classification framework.

# Workshop

## Installation

```{r install, warning=FALSE, message=FALSE, eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}

BiocManager::install(c( "simpleSeg", "cytomapper", "scClassify", "scHot", "FuseSOM", "spicyR", "lisaClust","Statial", "scFeatures", "ClassifyR", "tidyverse", "scater", "SingleCellExperiment", "STexampleData", "SpatialDatasets", "tidySingleCellExperiment", "scuttle", "batchelor"))
```

## Load packages

```{r library, warning=FALSE, message=FALSE}

#library(ScdneySpatial)

# packages from scdney
library(simpleSeg)
library(scClassify)
library(scHOT)
library(FuseSOM)
library(spicyR)
library(lisaClust)
library(Statial)
library(scFeatures) 
library(ClassifyR)
library(SpatialDatasets)

# Other required packages
library(scater)
library(tidyverse)
library(SingleCellExperiment)
library(STexampleData)
library(cytomapper)
library(tidySingleCellExperiment)
library(scuttle)
library(batchelor)

theme_set(theme_classic())
nCores <- 1  # Feel free to parallelise things if you have the cores to spare.
BPPARAM <- simpleSeg:::generateBPParam(nCores)
source(system.file("extdata", "celltype_colours.R", package = "ScdneySpatial"))
options("restore_SingleCellExperiment_show" = TRUE)
```

## The data

We will use two motivating datasets:

-   [Keren et al,
    2018](https://www.cell.com/fulltext/S0092-8674(18)31100-0): A
    multiplexed ion beam imaging by time-of-flight (MIBI-TOF) dataset
    profilining tissue from triple-negative breast cancer patients.
-   [Lohoff et al,
    2022](https://www.nature.com/articles/s41587-021-01006-2): A seqFISH
    study of early mouse organogenesis. We will use a subset of data
    that is made available from the STExampleData package.

## Data visualisation and exploration

Here we will download the datasets, examine the structure, visualise the
data and perform some exploratory analyses.

### SeqFISH mouse embryo

Here we download the seqFISH mouse embryo data. This is a
`SpatialExperiment` object, which extends the `SingleCellExperiment`
object.

```{r seqFISHData}
spe <- STexampleData::seqFISH_mouseEmbryo()
spe
```

We can use functions designed for `SingleCellExperiment` objects in the
`scater` package for plotting via the `reducedDim` slot. We multiply the
spatial coordinates by a matrix to flip the y-axis and ensure we fix the
aspect ratio.

```{r visualiseSeqFISH}
spe <- logNormCounts(spe)
coord_transform <- matrix(c(1,0,0,-1), 2, 2, byrow = TRUE)
reducedDim(spe, "spatialCoords") <- spatialCoords(spe) %*% coord_transform
plotReducedDim(spe, "spatialCoords", colour_by = c("Sox2"), point_size = 1) +
  coord_fixed()
```

::: question
**Questions**

1.  How many cells are in this data?
2.  How many genes?
3.  Plot gene expression mapping point size to the cell area.
:::

```{r seqFISHQ1}
# try to answer the above question using the spe object. 
# you may want to check the SingleCellExperiment vignette.
# https://bioconductor.org/packages/3.17/bioc/vignettes/SingleCellExperiment/inst/doc/intro.html


```

We can perform a typical gene-expression based analysis for this data.
Later in part two we will perform some specific analytical techniques,
but for now let's explore the dataset and use methods designed for
single cell data.

Dimensionality reduction using PCA, batch correction across tiles using
the `batchelor` package, followed by UMAP and plotting.

```{r seqFISHEDA}
spe <- runPCA(spe)

b.out <- batchelor::batchCorrect(spe, batch = spe$pos, assay.type = "logcounts", PARAM=FastMnnParam(d=20))
reducedDim(spe, "FastMnn") <- reducedDim(b.out, "corrected")
spe <- runUMAP(spe, dimred = "FastMnn")
spe

g_celltype_umap <- plotReducedDim(spe, "UMAP", colour_by = "celltype_mapped_refined") + 
  scale_colour_manual(values = celltype_colours)
g_celltype_umap

plotReducedDim(spe, "UMAP", colour_by = "Sox2")

g_celltype_spatial <- plotReducedDim(spe, "spatialCoords", colour_by = "celltype_mapped_refined") + 
  scale_colour_manual(values = celltype_colours) + 
  coord_fixed()

g_all <- g_celltype_spatial + theme(legend.position = "none") + g_celltype_umap
g_all
```

::: question
**Advanced/Extension Question**

1.  What considerations need to be made for batch correction of spatial
    data? What assumptions are being made and/or broken? How could you
    check this?
2.  Check out the
    [`ggiraph`](https://davidgohel.github.io/ggiraph/index.html) package
    for extending the `g_all` object to an interactive plot with a
    tooltip that links the spatial and UMAP coordinate systems. (Hint:
    This may involve generating a new ggplot object outside of the
    `plotReducedDim` function.)
:::

```{r seqFISHQ2}
# try to examine answer the above questions using the spe object. 
# you may want to set up some small simulation..


```

At this point we will pause our examination of the seqFISH dataset that
is in the object `spe`, and turn over to the second example dataset. In
the second part we will revisit this data for performing `scHOT`
testing.

### MIBI-TOF breast cancer

Here we explore the MIBI-TOF breast cancer data, this is also a
`SpatialExperiment` object.

```{r kerenData}
kerenSPE = SpatialDatasets::spe_Keren_2018() 


kerenSPE = kerenSPE |> 
  filter(tumour_type != "cold",
         !is.na(`Survival_days_capped.`)) |> 
  mutate(event = 1 - Censored)


kerenSPE
```

::: question
**Questions**

1.  How many cells are in this data?
2.  How many markers? How many images?
:::

```{r kerenQ1}
# try to answer the above question using the imc object. 
# you may want to check the SingleCellExperiment vignette.
# https://www.bioconductor.org/packages/release/bioc/vignettes/SpatialExperiment/inst/doc/SpatialExperiment.html

```

Use the following code to run a UMAP `intensities` assay.

::: question
**Questions**

1.  Visualise the UMAP using the `plotReducedDim` function and colour
    the UMAP by `cellType`. What does this UMAP tell us?
2.  What are some observations we could make if we coloured by
    `imageID`?
:::

```{r kerenQ2}
set.seed(51773)
kerenSPE <- scater::runUMAP(kerenSPE, exprs_values = "intensities", name = "UMAP")


# try to answer the question here!
```

## Cell segmentation & evaluation

### Reading images

To load in our images we use the `loadImages` function from
`cytomapper`, here we use the patient 5 image from Keren et al. as an
example.

```{r loadImage5}
image5 = cytomapper::loadImages(
  x = system.file("extdata", "kerenPatient5.tiff", package = "ScdneySpatial")
)

mcols(image5) = data.frame(list("imageID" = "kerenPatient5"))

# Setting the channel names according to orginal paper. 
channelNames(image5) = c("Au", "Background", "Beta catenin", "Ca", "CD11b", "CD11c", "CD138", "CD16", "CD20", "CD209", "CD3", "CD31", "CD4", "CD45", "CD45RO", "CD56", "CD63", "CD68", "CD8", "dsDNA", "EGFR", "Fe", "FoxP3", "H3K27me3", "H3K9ac", "HLA_Class_1", "HLA_DR", "IDO", "Keratin17", "Keratin6", "Ki67", "Lag3", "MPO", "Na", "P", "p53", "Pan-Keratin", "PD-L1", "PD1", "phospho-S6", "Si", "SMA", "Ta", "Vimentin")


```

### How do I perform segmentation in R?

Images stored in a `list` or `CytoImageList` can be segmented using
`simpleSeg`. Below `simpleSeg` will identify the nuclei in the image
using the `dsDNA`, `H3K27me3` and `H3K9ac` channel. To estimate the cell body of the cells we
will simply dilate out from the nuclei by 3 pixels. We also have
specified that the channels be sqrt transformed, and the 99th quantile
of values removed to ensure our segmentation is not affected by
outliers.

We can visualise the segmentations using the `display` and `colorLabels`
functions in `EBImage`.

```{r simpleSeg}

# Generate segmentation masks
masks <- simpleSeg(
  image5,
  nucleus = c("dsDNA", "H3K27me3", "H3K9ac"),
  cellBody = "dilate", 
  transform = c("sqrt", "norm99"),
  sizeSelection = 40,
  smooth = 3,
  discSize = 3,
  cores = nCores
)


# Visualise segmentation performance one way.
masks[[1]] |> 
  EBImage::colorLabels() |> 
  EBImage::display()

```


### Is this segmentation appropriate?

The `plotPixels` function in `cytomapper` makes it easy to overlay the masks on top of the intensities of markers in the image. Here we can s

```{r plotSegmentation}
# Visualise segmentation performance another way.
cytomapper::plotPixels(
  image = image5[1],
  mask = masks[1],
  img_id = "imageID",
  colour_by = c("CD45", "Pan-Keratin", "SMA", "dsDNA"),
  display = "single",
  colour = list(
    CD45 = c("black", "blue"),
    `Pan-Keratin` = c("black", "yellow"),
    SMA = c("black", "green"),
    dsDNA = c("black", "red")
  ),
  # Adjust the brightness, contrast and gamma of each channel.
  bcg = list(
    CD45 = c(0, 1, 0.5),
    `Pan-Keratin` = c(0, 1, 0.5),
    SMA = c(0, 1, 0.5),
    dsDNA = c(0, 1, 0.8)
  ),
  legend = NULL
)

```

Using the `table` function in R we can measure the pixel area of each cell and plot this on a histogram. In this dataset 1 µm is equivalent to $2.56$ pixels, we can transform the pixel area of a cell to physical area by dividing the pixel area by $2.56^2$. We can see below the majority of our cells are just below $100µm^2$, you should decide whether or not this is an appropriate size based on your knowledge of the cell types being imaged. 

```{r pixelArea}
# Get area of every cell
cellSize = table(masks[[1]])/(2.56^2)

# Filter out first index, which represents background
cellSize[2:length(cellSize)] |> 
  hist(breaks = 30,
       xlab = "Pixel area of cell (µm^2)",
       main = NULL) 

```



::: question
**Questions**

1.  Do our segmentations look better if other parameters are used?
    *Hint*: use the help function to see what other parameters are
    available in `simpleSeg`.
:::

### How to I convert my image and mask to an object I can use in R?

With our segmentation `masks` we can convert our image to a
`SpatialExperiment` object using the `measureObjects` function in
`cytomapper`. `measureObjects` will find the center of each cell and
represent the cell as an x and y coordinate. In addition the average
marker expression within each cell is summarised and stored in the
assays object of the `SpatialExperiment`. *NOTE:* If you are using other segmentation tools or softwares, you can import the masks as tiffs into R and use `measureObjects` to create a `SingleCellExperiment`.

```{r measureObjects}
# Summarise the expression of each marker in each cell
cells <- cytomapper::measureObjects(
  mask = masks,
  image = image5,
  feature_types = c("basic", "moment"),
  basic_feature = "mean",
  moment_feature = c("cx", "cy"),
  img_id = "imageID",
  BPPARAM = BPPARAM
)


cells
```

## Feature normalisation

Before moving onto annotating the cell types, we should check if the marker intensities of each cell require any transformation or normalisation. Here we examine the distribution of CD45 in each cell across all the images, which is a general marker for immune cells. Below we can see that the intensity of CD45 looks very skewed. 

```{r viewingProteinDensity}
# Joining the marker information with the cell information
proteinIntensities = kerenSPE |> 
  join_features(features = rownames(kerenSPE), shape = "wide", assay = "intensities")

# View the density of CD45 across all images.
ggplot(proteinIntensities, aes(x = CD45, colour = imageID)) +
  geom_density() +
  theme(legend.position = "none")
```

We can transform and normalise our data using the `normalizeCells` function in `simpleSeg`. Here we have taken the intensities from the `intensities` assay, performed a asinh transform, then for each image trimmed the 99 quantile and min-max scaled to 0-1. In addition to this we have performed principle component analysis, and regressed out the first PC. This modified data is then stored in the `normIntensities` assay. We can see that the distribution of CD45 looks much less skewed than before. 

```{r kerenNormalise}
kerenSPE <- normalizeCells(
  cells = kerenSPE,
  transformation = "asinh",
  method = c("trim99", "minMax", "PC1"),
  assayIn = "intensities",
  assayOut = "normIntensities",
  cores = nCores
)


normProteinIntensities = kerenSPE |> 
  join_features(features = rownames(kerenSPE), shape = "wide", assay = "normIntensities")


ggplot(normProteinIntensities, aes(x = CD45, colour = imageID)) +
  geom_density() +
  theme(legend.position = "none")
```


::: question
**Questions**

1. CD3 is a marker which characterises T cells, plot the distribution of CD3. What does it look like? What does this tell us about T cells in our dataset.
:::


```{r normaliseQ1}
# Answer question here
```



## Cell type annotation

### Cell type clustering

#### Clustering cell types

Here we cluster using the `runFuseSOM` function from `FuseSOM`. We have
chosen to specify the same subset of markers used in the original
manuscript for gating cell types. We have also specified the number of
clusters to identify to be `numClusters = 17`.

```{r fuseSOM}

useMarkers = c("CD45", "FoxP3", "CD4", "CD8", "CD3", "CD20", "CD16", "CD68", "MPO", "HLA.DR", "Pan.Keratin", "Keratin17", "Keratin6", "p53", "Beta.catenin", "EGFR")

set.seed(51773)

kerenSPE <- runFuseSOM(
  kerenSPE,
  markers = useMarkers,
  assay = "normIntensities",
  numClusters = 17
)

```

#### Cluster Interpretation

We can begin the process of understanding what each of these cell
clusters are by using the `plotGroupedHeatmap` function from `scater`.

```{r heatmap}
scater::plotGroupedHeatmap(
  kerenSPE,
  features = useMarkers,
  group = "clusters",
  exprs_values = "normIntensities",
  center = TRUE,
  scale = TRUE,
  zlim = c(-3, 3),
  cluster_rows = FALSE
)

```






::: question
**Questions**

1.  Have we captured distinct cell populations? Can you identify any of
    the clusters?
2.  Run the code below to compare the cell types in the dataset to the clusters we have identified. How do our clusters compare? Are there any clusters that should be combined? 
:::

```{r clusteringQ1}
# Type your answer here


# Question 2 code
regionMap(kerenSPE, cellType = "clusters", region = "cellType") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)) +
  labs(x = "Cell types in data", y = "Our clusters")
```

#### How do I determine an appropriate number of clusters?

Great question! There is no right answer here, however there are several statistics which can be used to estimate the "true" number of clusters. We can use the `estimateNumCluster` and `optiPlot`
functions from `FuseSOM` to examine if our choice of 17 clusters is
reasonable. Here we use the gap statistic, other methods such as jump, slope,
silhouette and within cluster distance (wcd) are also available.

```{r optiPlot}
kerenSPE <- estimateNumCluster(kerenSPE, kSeq = 2:30)
optiPlot(kerenSPE, method = "gap")

kerenSPE@metadata$clusterEstimation$Discriminant
```
Finally we can run a UMAP to examine how distinct our clusters are from one another. 

```{r normUMAP}
set.seed(51773)
# Perform dimension reduction using UMP.
kerenSPE <- scater::runUMAP(
  kerenSPE,
  subset_row = useMarkers,
  exprs_values = "normIntensities",
  name = "normUMAP"
)



# UMAP by cell type cluster.
scater::plotReducedDim(
  kerenSPE,
  dimred = "normUMAP",
  colour_by = "clusters"
)
```

::: question
**Questions**

1.  How does this UMAP compare to the original UMAP. 
:::


```{r clusteringQ2}
# Answer question here.
```


### Cell type classification

Cell type clustering may difficult without the aid of domain experts who
know how many cell types to expect and are able to annotate the clusters. Cell type classification is an
alternative approach to clustering which annotates cell types based on an expert labeled
reference dataset.

*TO FILL* - Need a reference dataset with similar markers to keren: [1]
"Na" "Si" "P" "Ca" "Fe" "dsDNA"\
[7] "Vimentin" "SMA" "Background" "B7H3" "FoxP3" "Lag3"\
[13] "CD4" "CD16" "CD56" "OX40" "PD1" "CD31"\
[19] "PD.L1" "EGFR" "Ki67" "CD209" "CD11c" "CD138"\
[25] "CD163" "CD68" "CSF.1R" "CD8" "CD3" "IDO"\
[31] "Keratin17" "CD63" "CD45RO" "CD20" "p53" "Beta.catenin" [37]
"HLA.DR" "CD11b" "CD45" "H3K9ac" "Pan.Keratin" "H3K27me3"\
[43] "phospho.S6" "MPO" "Keratin6" "HLA_Class_1" "Ta" "Au"

### Viewing images

We can look at the distribution of cells in an image. Here we compare
our clusters to the cell types in the dataset.

```{r viewClustering}
reducedDim(kerenSPE, "spatialCoords") <- spatialCoords(kerenSPE)

kerenSPE |> 
  filter(imageID == "5") |> 
  plotReducedDim("spatialCoords", colour_by = "clusters") +
  ggtitle("Our clusters")


kerenSPE |> 
  filter(imageID == "5") |> 
  plotReducedDim("spatialCoords", colour_by = "cellType") +
  ggtitle("Dataset clusters")


```

## Feature generation
